---
title: 2026.02.09 데이터베이스 기초(9)
date: 2026-02-09
categories: [국비교육]
tags: [database, mysql]
---

#### 트리거
- 테이블에 삽입, 수정, 삭제 등의 작업(이벤트)이 발생할 때에 작동하는 데이터베이스 개체
- 프로시저와 달리 직접 실행시킬 수 없고 오직 해당 테이블에 이벤트가 발생할 경우에만 실행 (매개변수 사용불가)
- 이벤트 발생한 후 ROLLBACK 할 수 없다.

단점
- 디버깅 어려움
- 유지 보수 복잡성 증가 :  애플리케이션의 설치나 배포가 더 복잡해짐 ( 각 기능을 담당하는 프로그램 코드가 자바와 MySQL 스토어드 프로그램으로 분산되어 관리하기 때문에 )

구문)

```
DROP TRIGGER IF EXISTS 트리거명;

-- 트리거 선언
DELIMITER $$
CREATE TRIGGER IF NOT EXISTS 트리거명
[AFTER/BEFORE] [INSERT/UPDATE/DELETE] ON [테이블명]
FOR EACH ROW
BEGIN 

END $$

DELIMITER ;
```


## 트랜잭션
- 하나의 작업을 수행하기 위해 필요한 데이터베이스 연산들을 모아 놓은 것
- 작업 수행에 필요한 SQL 문들의 모임
- 논리적인 작업의 단위
- 장애 발생 시 복구 작업이나 병행 제어 작업을 위한 중요한 단위로 사용됨
- 데이터 베이스의 무결성과 일관성을 보장하기 위해 작업 수행에 필요한 연산들을 하나의 트랜잭션으로 제대로 정의하고 관리해야 함

트랜잭션 특성 ACID
- 원자성 (Atomicity)
	- 트랜잭션의 연산들이 모두 정상적으로 실행되거나 하나도 실행되지 않아야하는 all-or-nothing
	- all-or-nothing : 트랜잭션 수행 도중 장애가 발생하면 지금까지 실행한 연산을 모두 취소하고 수행 전 상태로 되돌려야 한다.
- 일관성 (Consistency)
	- 트랜잭션이 성공적으로 수행된 후에도 데이터베이스가 일관성 있는 상태를 유지해야한다.
	- 제약조건, 데이터 무결성
- 격리성 (Isolation)
	- 수행 중인 트랜잭션이 완료될 때까지 다른 트랜잭션들이 중간 연산 결과에 접근할 수 없다.
	- 여러 트랜잭션이 동시에 수행되더라도 마치 순서대로 하나씩 수행되는 것처럼 정확하고 일관된 결과를 얻을 수 있도록 제어하는 기능 필요
- 영속성, 지속성 (Durability)
	- 트랜잭션이 성공적으로 완료된 후 데이터베이스에 반영한 수행 결과는 영구적이어야 한다.
	- 지속성의 보장을 위해서는 장애 발생 시 회복 기능이 필요


트랜잭션 상태
- 활동상태
	- 트랜잭션이 수행을 시작하여 현재 수행 중인 상태
- 부분완료상태
	- 트랜잭션의 마지막 연산이 실행을 끝낸 직후의 상태
- 완료상태
	- 트랜잭션이 성공적으로 완료되어 COMMIT연산을 실행한 상태
	- 트랜잭션이 수행한 최종 결과를 데이터베이스에 반영하고 데이터베이스가 새로운 일관된 상태가 되면서 트랜잭션 종료됨.
- 실패상태
	- 장애가 발생하여 트랜잭션의 수행이 중단된 상태
- 철회상태
	- 트랜잭션의 수행실패로 ROLLBACK 연산을 실행한 상태
	- 지금까지 실행한 트랜잭션의 연산을 모두 취소하고 트랜잭션이 수행되기 전의 데이터베이스 상태로 되돌리면서 트랜잭션이 종료됨.
	- 철회 상태로 종료된 트랜잭션은 상황에 따라 다시 수행되거나 폐기됨.

구문)

```
-- 자동 커밋 여부 확인
SELECT @@autocommit;
-- 자동 커밋 여부 비활성화
SET @@autocommit:=0;
-- 자동 커밋 여부 확인
SELECT @@autocommit;
-- 트랜잭션 시작
START TRANSACTION;
SELECT * FROM gugu;
DELETE FROM gugu;`
SELECT * FROM gugu;
-- 트랜잭션 철회
ROLLBACK;
SELECT * FROM gugu;
```

세이브포인트)

```
-- 자동 커밋 여부 확인
SELECT @@autocommit;
-- 자동 커밋 여부 비활성화
SET @@autocommit:=0;
-- 자동 커밋 여부 확인
SELECT @@autocommit;
-- 트랜잭션 시작
START TRANSACTION;
INSERT INTO gugu(`result`) VALUES ('삽입1');
SAVEPOINT a; 
DELETE FROM gugu WHERE result = '삽입1';
SAVEPOINT b;
SELECT * FROM gugu;
-- 트랜잭션 철회
ROLLBACK TO SAVEPOINT a; 
SELECT * FROM gugu;
```