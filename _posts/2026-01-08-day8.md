---
title: 2026.01.08 데이터베이스 기초(2)
date: 2026-01-08
categories: [국비교육]
tags: [database, mysql]
---

## SQL 언어
DDL : CREATE(객체 생성), ALTER(생성된 구조 변경), DROP(생성된 객체를 삭제), TRUNCATE(테이블 내용 삭제) <br>
DML : SELECT(내용 조회), INSERT(내용 상입), UPDATE(내용 수정), DELETE(내용 삭제)

**테이블의 내용 삭제 : TRUNCATE** <br>
-- TRUNCATE TABLE members;

**기본키 설정** <br>
-- ALTER TABLE 설정할 테이블명 ADD PRIMARY KEY (기본키 설정할 컬럼명); <br>
-- ALTER TABLE 설정할 테이블명 ADD CONSTRAINT 기본키이름 PRIMARY KEY (기본키 설정할 컬럼명); <br>
-- ALTER TABLE members ADD PRIMARY KEY (mbr_id); <br>
*테이블 복제 시, 키는 복제되지 않는다.

**특수한 조건 쿼리 INSERT**
- ON duplicate KEY UPDATE 키의 내용이 중복이 발생됐을 때 특정 컬럼의 내용을 수정하는 문법
- IGNORE : 삽입시 키의 내용이 중복일 경우 무시

**SELECT 속성**
- 실행순서 : FROM -> WHERE -> SELECT -> DISTINCT -> ORDER BY -> LIMIT
- 정렬 : ORDER BY 정렬할 컬럼 (asc(오름차순) | desc(내림차순)), 정렬할 컬럼 (asc(오름차순) | desc(내림차순))
- 기본 정렬은 오름차순 정렬
- ORDER BY mbr_id, mbr_name DESC / mbr_id는 오름차순, mbr_name은 내림차순
- LIMIT 보여줄 행의 갯수
- LIMIT 보여줄 행의 시작점(시작: 0부터 시작), 보여줄 행의 갯수
- DISTINCT : 중복행 제거 (조회 시의 행을 기준으로 중복체크)

## 데이터 모델링

#### 데이터 모델링이란
- 복잡한 현실 세계에 존재하는 데이터를 단순화 시켜 표현해 컴퓨터 세계의 데이터베이스로 옮기는 변환 작업
- 업무에 필요로 하는 데이터를 파악하여 데이터베이스를 구축하기 위한 분석/설계의 과정
- 현실세계 -> 개념세계 -> 컴퓨터세계

#### 데이터 모델링 특징
- 추상화(Abstraction) : 현실세계를 일정한 형식에 맞추어 간략하게 표현
- 단순화(Simple) : 복잡한 현실세계를 약속된 규약에 의해 제한된 표기법이나 언어로 쉽게 이해할 수 있도록 표현
- 명확성(Clarity) : 명확하게 의미가 해석되어야 하고 한 가지 의미를 가져야 함. (애매모호 x)

#### 데이터베이스의 개념도
개념적 데이터 모델
- **추상화**의 수준이 높고 업무 중심적이고 포괄적인 수준
- 조직, 사용자의 데이터 요구사항을 찾고 분석하여 데이터들 간의 관계를 발견하고 이를 표현하기 위해 ER다이어그램 생성

논리적 데이터 모델
- 시스템으로 구축하고자 하는 업무에 대해 key, 속성, 관계 등을 정확하게 표현 **(정규화 진행, DBMS 결정x)**

물리적 데이터 모델
- 실제로 데이터베이스에 이식할 수 있도록 성능, 저장 등 물리적인 성격을 고려하여 설계 **(하드웨어 및 DBMS 결정o)**

#### 게채-관계 모델
개체 (Entity)
- 업무에 필요하고 유용한 정보를 저장하고 관리하기 위한 집합적인 것
- ex) 사람, 장소, 물건, 개념 등의 명사

속성 (Attribute)
- 업무에서 필요로 하는 인스턴스로 관리하고자 하는 의미상 더 이상 분리되지 않는 최소의 데이터 단위 
- ex)강사-이름,주소,생년월일,계약일자

관계 (Relationship)
- 엔터티의 인스턴스 사이의 논리적인 연관성으로서 존재의 형태로서나 행위로서 서로에게 연관성이 부여된 상태
- ex) 학생(엔티티) - 수강(관계) - 강좌(엔티티) '학생이 강좌를 수강한다'

식별자 (Identifiers)
- 하나의 엔티티에 구성되어 있는 여러 개의 속성 중에 엔티티를 대표할 수 있는 속성
- ex) 학생 : 학생번호(식별자), 학생이름, 학생주소, 학생연락처

#### 데이터베이스의 키워드
데이터베이스 스키마
- 데이터베이스의 전체구조, 테이블의 구조와 속성에 대한 정보

데이터베이스 인스턴스
- 정의된 스키마에 따라 데이터베이스에 실제로 저장된 값
- 데이터베이스를 구성하는 릴레이션 인스턴스의 모음

## 릴레이션

#### 릴레이션의 특성
튜플의 유일성 - 하나의 릴레이션에는 동일한 튜플이 존재할 수 없다. <br>
튜플의 무순서 - 하나의 릴레이션에서 튜플 사이의 순서는 무의미하다. <br>
속성의 무순서 - 하나의 릴레이션에서 속성 사이의 순서는 무의미하다. <br>
속성의 원자성 - 속성 값은 논리적으로 더 이상 쪼갤 수 없는 원자 값만을 저장한다.

#### 릴레이션의 키(식별자)

**릴레이션 키란** <br>
릴레이션에서 투플들을 유일하게 구별하는 속성 또는 속성들의 집합

**릴레이션 키의 특성**  <br>
유일성
- 하나의 키 값으로 하나의 튜플만을 유일하게 식별
- 한 릴레이션에서 모든 튜플은 서로 다른 키 값을 가져야 함

최소성
- 꼭 필요한 최소한의 속성들로만 키를 구성

**릴레이션 키의 종류** <br>
기본키 (Primary key)
- 후보키 중에서 기본적으로 사용하기 위해 선택한 키 
- 예) 고객 릴레이션의 기본키 : 고객아이디

후보키 (Candidate key)
- 유일성과 최소성을 만족하는 속성 또는 속성들의 집합
- 예) 고객 릴레이션의 후보키: 고객아이디, (고객이름, 주소) 등

대체키 (Alternate key)
- 기본키로 선택되지 못한 후보키
- 예) 고객 릴레이션의 대체키 : (고객이름, 주소)

슈퍼키 (Super key)
- 유일성을 만족하는 속성 또는 속성들의 집합
- 예) 고객 릴레이션의 슈퍼키: 고객아이디, (고객아이디, 고객이름), (고객이름, 주소) 등

외래키 (Foreign key)
- 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합
- 릴레이션들 간의 관계를 표현
- 참조하는 릴레이션 : 외래키를 가진 릴레이션
- 참조되는 릴레이션 : 외래키를 참조하는 기본키를 가진 릴레이션

#### 무결성 제약조건

**무결성 제약조건이란**
- 무결성 : 데이터가 결함이 없는 상태, 즉 정확하고 유효하게 유지하는 것
- 데이터의 무결성을 보장하고 일관된 상태로 유지하기 위한 규칙
- 도메인 무결성 제약조건, 개체 무결성 제약조건, 참조 무결성 제약조건이 있다.

**도메인 무결성 제약조건**
- 특정 속성의 값이 그 속성이 정의된 도메인에 속한 값이어야 한다는 규칙
- NULL 값은 허용됨 ( NOT NULL 아닌 경우)
- NULL : 공백이나 숫자0과는 전혀 다른 값이며, 조건에 맞는 데이터가 없을 때의 공집합도 아니다. <br> 
아직 정의되지 않은 미지의 값, 현재 데이터를 입력하지 못하는 경우의 값을 의미

**개체 무결성 제약조건**
- 기본키를 구성하는 모든 속성은 null 값을 가질 수 없는 규치

**참조 무결성 제약조건**
- 외래키는 참조할 수 없는 값을 가질 수 없는 규치 <br>
(null 값을 가진다고 해서 위반한 것은 아님)
- RESTRICT : 레코드를 변경 또는 삭제하고자 할 때 레코드를 참조하는 개체가 있다면, 변경 또는 삭제 연산을 취소 (기본값)
- CASCADE : 레코드를 변경 또는 삭제하면, 해당 레코드를 참조하고 있는 개체도 변경 또는 삭제
- SETNULL : 레코드를 변경 또는 삭제하면, 해당 레코드를 참조하고 있는 개체의 값을 NULL로 설정

## 데이터 타입

#### 숫자 데이터 타입
INT : 4바이트 | 약 -21억 ~ +21억 데이터 범위 | 정수 <br> 
BIGINT : 8바이트 | 약 -900경 ~ +900경 데이터 범위 | 정수 <br>
FLOAT : 4바이트 | -3.40E+38 ~ 1.79E-38 데이터 범위 | 소수점 7자리 <br>
DOUBLE : 8바이트 | -1.22E-308 ~ 1.79E+308 데이터 범위 | 소수점 15자리

#### 날짜 데이터 타입
DATE : 3바이트 | 날짜: 1001-01-01 ~ 9999-12-31까지 저장 <br>
ex) 날짜: 1001-01-01 ~ 9999-12-31까지 저장 <br>
TIME : 3바이트 | 시간: -838:59:59.000000 ~ 838:59:59.000000까지 저장 <br>
ex) 형식: ‘HH:MM:SS’ <br>
DATETIME : 8바이트 | 날짜: 1001-01-01 00:00:00 ~ 9999-12-31 23:59:59 저장 <br>
ex) 형식: ‘YYYY-MM-DD HH:MM:SS’ <br>
TIMESTAMP : 4바이트 | 날짜: 1970-01-01 00:00:00 ~ 2037-12-31 23:59:59 저장 <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Time_zone 시스템 변수와 관련 있으며 UTC 변환 저장 <br>
ex) 형식: ‘YYYY-MM-DD HH:MM:SS’
