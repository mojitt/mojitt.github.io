---
title: 2026.01.19 java 기초(4)
date: 2026-01-19
categories: [국비교육]
tags: [java]
---

## 참조타입

데이터 타입 분류
- 기본 타입 변수는 실제 값을 변수 안에 저장 ex) byte, char, short, int, long, float, double
- 참조 타입 변수는 주소를 통해 객체 참조 ex) 배열, 열거, 클래스, 인터페이스

**메모리 사용 영역**
1. 메소드 영역
- JVM 시작할 때 생성
- 로딩된 클래스 바이트 코드 내용을 분석 후 저장
- 모든 스레드가 공유

2. 힙 영역 
- JVM 시작할 때 생성
- 객체/배열 저장
- 사용되지 않는 객체는 Garbage Collector 가 자동 제거

3. JVM 스택 영역
- 스레드 별 생성
- 메소드 호출할 때마다 Frame을 스택에 추가(push)
- 메소드 종료하면 Frame 제거(pop)

#### 참조타입 null
null 타입

```
String a = "A";
String b = null;
		
boolean result;

//result = b.equals("A"); //NullPointerException 발생
//System.out.println("b 변수 값은 A인가요? "+result);	

if(b != null) { //참조 변수의 null값은 동등비교 연산자로 비교합니다.
	result = b.equals("A");
	System.out.println("b 변수 값은 A인가요? "+result);	
}
```

- 변수가 참조하는 객체가 없을 경우 초기값으로 사용 가능
- 참조 타입의 변수에만 저장가능
- null로 초기화된 참조 변수는 스택 영역 생성
- NullPointerException : 참조 변수가 null 값을 가지고 있을 때, 객체의 필드나 메소드를 사용하려고 했을 때 발생
- 해결책 -> if문을 통해 데이터가 null 값인지 확인하여 실행

#### 참조타입 String
String 타입
```
//문자열 타입 기능 종류들

//1. charAt 기능 : 문자열에서 문자 한글자를 추출 / 반환 타입 : char

String str = "abcdefg";
		
char result;
		
result = str.charAt(3); // 해당위치는 몇번째 -1 값을 전달합니다. (맨 앞글자 0번부터 시작)
System.out.println("str.charAt(3) -> "+result);


//2. length 기능 : 문자열의 길이를 반환 / 반환 타입 : int

str = "자바 너무 재밌어요!";
		
int result2;
		
result2 = str.length();
System.out.println("str 변수의 문자열 길이 -> "+result2);


//3. replace 기능 : 문자열의 특정 문자열을 다른 문자열로 치환 / 반환 타입 : String

str = "자바 프로그래밍";
		
String result3;
		
result3 = str.replaceAll("자바", "java"); // .replace(대상문자열, 변경문자열)
System.out.println("str 치환 결과 -> "+result3);
System.out.println("str 변수 값 -> "+str); // 치환에 사용한 문자열은 바뀌지 않습니다.


//4. substring 기능 : 문자열 잘라내기 기능 / 반환 타입 : String

str = "String substring example";
		
String result4;
		
result4 = str.substring(7, 16); // .substring(시작번호, 종료번호+1)
System.out.println("str.substring(7, 16) -> "+result4);
System.out.println("str 치환 결과 -> "+str); // 사용한 문자열은 변경 X
		
result4 = str.substring(17); // .substring(시작번호) -> 시작번호 부터 문자열 끝까지
System.out.println("str.substring(17) -> "+result4);


//5. indexOf 기능 : 문자열에 특정 문자열 포함여부 찾기 기능 / 반환 타입 : int

str = "java programming";
		
int result5; 
		
result5 = str.indexOf("java"); // java 문자열 여부 / 문자열의 시작 인덱스 번호 반환
System.out.println("str.indexOf(\"java\") -> "+result5); 
		
result5 = str.indexOf("profile");
System.out.println("str.indexOf(\"profile\") -> "+result5);
		
if(str.indexOf("profile")>-1) { // indexOf의 결과가 -1이면 검색 문자열이 없다는 의미입니다.
	System.out.println("문자열에 \"profile\" 은 포함되어 있습니다.");
} else {
	System.out.println("문자열에 \"profile\" 은 포함되어 있지 않습니다.");
}


//6. contains 기능 : 검색 문자열이 있으면 true 없으면 false 반환
		
//if(str.contains("java"))
if(str.contains("java")==true) {
	System.out.println("str에는 java가 있습니다.");
}
//if(str.contains("html"))
if(str.contains("html")==true) {
	System.out.println("str에는 html가 있습니다.");
}
//if(!str.contains("python"))
if(str.contains("python")==false) {
	System.out.println("str에는 python이 없습니다.");
	}


//7. split 기능 : 문자열에서 구분자를 기준으로 분리하여 문자열 집단(배열) 만드는 기능 / 반환 타입 : 배열
		
str = "java,html,css,mysql";
		
String[] result7; // 문자열 집단을 담을 수 있는 변수 result7 선언
		
result7 = str.split(",");
System.out.println(result7[0]);
System.out.println(result7[1]);
System.out.println(result7[2]);
System.out.println(result7[3]);
```
- 문자열 리터럴 동일하다면 String 객체 공유
- new 연산자를 이용한 String 객체 생성


#### 배열 타입
배열
- 같은 데이터 타입인 데이터들을 연속된 공간에 저장하는 구조입니다.
- 담기는 순서대로 0 ~ n-1까지의 인덱스를 부여 받습니다.
- 각 공간에 담긴 데이터를 원소라고 부릅니다.
- 중복된 변수 선언 줄이기 위해 사용
- 반복문 이용해 요소들을 쉽게 처리

```
//1. 배열변수의 선언
		
int[] arr1; // 타입[] 변수명 <- 가장 많이 사용
int arr2[];  // 타입 변수명[]
	
double[] arr3;// 실수 double 타입 arr3 변수 선언
String[] arr4;// 문자열 타입 arr4 변수 선언


//2. 배열 변수에 값 대입하기
		
int[] arr5 = {1,2,3,4,5}; // 변수 선언과 동시에 배열 대입하기(배열 리터럴값)
arr1 = new int[]{1,2,3,4,5}; // 변수 선언 후 배열 대입하기(new 타입[]{배열 리터럴})
		
int[] arr6 = null; // 참조 없음(빈그릇)

int[] arr7 = new int[10]; // 배열의 공간 갯수만 미리 할당 받으면 선언하는 방법
arr7[0] = 10; // 배열 특정 인덱스 원소 값 대입

//3. 배열 원소 읽기
		
int value = arr5[2];
		
System.out.println("arr5의 2번 인덱스 원소 -> "+value);
		
System.out.println("arr1의 4번 인덱스 원소 -> "+arr1[4]);
// 만약 존재하지 않는 넘치는 인덱스에 접근하면 실행시 ArrayIndexOutOfBoundsException 발생
```


#### 배열의 길이
length 기능 사용하여 배열의 기능을 알 수 있습니다.

```
System.out.println("arr8의 원소 갯수 -> "+arr8.length);
		
for(int i=0; i<arr8.length; i++) { // for(int i=0; i<배열.length; i++){} 선언을 사용하여 배열의 모든 원소 접근 for 작성
	System.out.println(arr8[i]);
}

//arr8.length = 6; 배열의 길이는 고정으로 값을 변경할 수 없습니다.
```

#### 객체를 참조하는 배열
기본타입과 참조타입의 차이

```
int[] intArr = {1,1,2,3};
		
System.out.println(intArr[0]==intArr[1]); // 기본타입 배열은 인덱스에 원소값을 갖으므로 동등비교 연산자 비교 가능
		
String[] strArr = {"A",new String("A"),"A"};
 		
System.out.println(strArr[0]==strArr[1]); // 참조타입 배열은 인덱스에 원소의 주소값을 가지므로 동등비교 연산자 비교 X
System.out.println(strArr[0]==strArr[2]); // 문자열 리터럴은 같은 소스파일 내에서는 같은 주소를 가지므로 등등비교 연산자 값 비교 가능
```

#### 다차원 배열
이차원 배열 : 행과 열을 갖는 배열 구조

```
/*
{
    {1,2,3}
    ,
    {4,5,6}
    ,
    {7,8,9}
}		 
 */

int[][] arr1 = { {1,2,3,},{4,5,6,},{7,8,9} }; // 배열 변수 선언시 리터럴 이차원 배열 대입
		
arr1 = new int[][] { {1,2,3,},{4,5,6,},{7,8,9} }; // 배열 변수 선언 후 리터럴 이차원 배열 대입
		
int[][] arr2 = new int[2][3]; // { {0,0,0},{0,0,0} }
		
System.out.println("arr1 2행 3열 원소 -> "+arr1[1][2]); // 6
System.out.println("arr1 8값 출력 -> "+arr1[2][1]); // 8
```

#### 배열복사
배열 복사
- System.arraycopy 기능 사용하여 배열 복사하기
- System.arraycopy(원본배열, 복사시작인덱스, 새로운배열, 복사시작인데스(새로운배열), 갯수)

```
String[] strArray = {"A","B","C"};
String[] newStrArray = new String[5]; // {null,null,null,null,null}
		
System.arraycopy(strArray, 0, newStrArray, 2, strArray.length);

for(int i=0; i<newStrArray.length; i++) {
	System.out.println("newStrArray[i] -> "+newStrArray[i]);
}
```

향상된 for문 복사
- for(원소 변수 : 배열){ 원소 변수를 사용 }

```
int[] intArray = {20,33,50,10,27};
int sum = 0;
 
for(int value : intArray) { //value에 intArray 배열의 값을 받아옴
	sum += value;
}
System.out.println("intArray 합계 -> "+sum); // 140
```

#### enum 타입
모든 곳에서 같은 값이면 같은 주소를 가질 수 있는 타입 <br>
모든 작업방 또는 프레임에서 같은 값이면 같은 주소를 갖습니다. <br>
한정된 값만을 갖는 데이터 타입 <br>
한정된 값은 열거 상수(Enumeration Constant)로 정의 <br>
열거 타입 변수는 참조 타입이므로 null 값 저장 가능

타입 선언
- 파일 이름과 동일한 이름으로 다음과 같이 선언 (첫 글자 대문자)
- 한정된 값인 열거 상수 정의
- 열거 상수 이름은 관례적으로 모두 대문자로 작성

변수 선언
- 열거타입 변수명;

열거 상수 값 저장
- 열거타입 변수 = 열거타입.열거상수;




