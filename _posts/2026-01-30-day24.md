---
title: 2026.01.30 java 기초(11)
date: 2026-01-30
categories: [국비교육]
tags: [java]
---

## 익명 객체

익명 객체 : 이름이 없는 객체
- 익명 객체는 단독 생성 불가 
	- 클래스 상속하거나 인터페이스 구현해야만 생성 가능
- 사용위치
	- 필드의 초기값, 로컬 변수의 초기값, 매개변수의 매개값으로 주로 대입
	- UI 이벤트 처리 객체나, 스레드 객체를 간편하게 생성할 목적으로 주로 활용

#### 익명 자식 개체
- 타입 즉 클래스 없이 생성될 수 있는 객체를 의미합니다.

```
//Parent.class

public class Parent {
	
	public String field1;
	
	public void method1() {
		System.out.println("Parent의 method1");
	}

}
```

```
//Child1.class

public class Child1 extends Parent {
	
	@Override
	public void method1() {
		System.out.println("자식 Child1에서 재정의");
	}
	
	public void method2() {
		System.out.println("Child1의 method2");
	}
	
}
```

```
//Main.class

Parent p2;
p2 = new Parent() {
	//익명 자식 객체의 클래스 내부
	String field2 = "익명 자식 객체";
	
	void method2() {
		System.out.println("익명 객체 메소드");
	}
};	
p2.field1 = "부모 객체 필드";
p2.method1(); //Parent 클래스의 method1 출력

//p2.field2 = "익명 자식 객체"; 익명 자식 객체는 부모 타입 변수에 대입되므로 본인의 멤버는 사용할 수 없다.
//p2.method2();

Parent p3 = new Parent() {
	@Override
	public void method1(){
		System.out.println("익명 자식 객체에서 재정의");
	}
};
p3.method1(); //익명 자식 객체에서의 method1 출력
```

#### 익명 구현 객체
- 인터페이스에 대입되는 타입 없는 구현 객체

```
//SampleInterface.interface

public interface SampleInterface {
	
	void method3();
	void method4(String arg);
	
}
```

```
//ImpleClass.class

public class ImpleClass implements SampleInterface {

	@Override
	public void method3() {
		System.out.println("ImpleClass에서 구현한 method3");
	}

	@Override
	public void method4(String arg) {
		int result = Integer.parseInt(arg);
		System.out.println(result + 10);
	}

	public void method5() {
		System.out.println("ImpleClass의 method5");
	}
}
```

```
//Main.class

SampleInterface sample2 = new SampleInterface() {
			
	@Override
	public void method3() {
		System.out.println("익명의 구현 객체에서 재정의");
	}
			
	@Override
	public void method4(String arg) {
		double result = Double.parseDouble(arg);
		System.out.println(result / 0);
	}
			
};
sample2.method3(); //익명의 구현 객체에서 재정의한 method3 출력
sample2.method4("20"); //익명의 구현 객체에서 재정의한 method4 출력
```


## 예외와 예외 클래스

#### 오류의 종류
에러(Error)
-  하드웨어의 잘못된 동작 또는 고장으로 인한 오류
- 에러가 발생되면 프로그램 종료
- 정상 실행 상태로 돌아갈 수 없음

예외(Exception)
- 사용자의 잘못된 조작 또는 개발자의 잘못된 코딩으로 인한 오류
- 예외가 발생되면 프로그램 종료
- 예외 처리 추가하면 정상 실행 상태로 돌아갈 수 있음

#### 예외의 종류
일반(컴파일 체크) 예외(Exception)
- 예외 처리 코드 없으면 컴파일 오류 발생

실행 예외(RuntimeException)
- 예외 처리 코드를 생략하더라도 컴파일이 되는 예외
- 경험 따라 예외 처리 코드 작성 필요

**1. NullPointerException**  
객체 참조가 없는 상태
- 참조 객체가 없는 변수를 사용하려 할 때(.연산자) 발생
- 참조 배열이 없는 변수를 사용하려 할 때([]인덱스 접근) 발생

```
String str = null;
String str2 = null;
String str3 = "A";
		
System.out.println(str3.equals("A"));
//System.out.println(str.length()); NullPointerException 발생
		
String[] strs = null;
//strs[0] = 'A'; NullPointerException 발생
```

**2. NumberFormatException**  
- 숫자로 변경할 수 없는 문자열을 변경할 때 발생합니다.

```
String number = "1 0";
//System.out.println(Integer.parseInt(number)); 1과 0 사이에 공백이 들어있으므로 NumberFormatException 발생

System.out.println(Boolean.parseBoolean(number)); //변환 할 수 없는 문자열도 오류를 내지 않는다.
```

**3. ArrayIndexOutOfBoundsException**  
- 배열에서 존재하지 않는 인덱스에 접근 할 때 발생하는 예외 입니다.

```
/*
String[] strs2 = new String[3];
for(int i=0; i<=strs2.length; i++) {
	System.out.println(strs2[i]);
}
*/  // ArrayIndexOutOfBoundsException  발생
```

**4. ArithmaticException**  
- by zero -> 수를 0으로 나누거나 나머지를 구하는 경우 발생하는 예외입니다.

```
//System.out.println(10/0);
```		
		
**5. ClassCastException**
- 부모객체를 자식 타입으로 형변환 하거나 인터페이스를 구현 객체의 클래스 타입으로 형변환 할 때 발생 할 수 있는 예외입니다.
- 잘못된 강제 형변환
		
		
**6. ClassNotFoundException**  
- 해당 클래스 존재x 경우 발생 예외
		
**7. FileNotFoundException**  
- 해당 파일 존재x 경우 발생 예외


#### 예외 처리 코드
예외 발생시 프로그램 종료 막고, 정상 실행 유지할 수 있도록 처리
- 일반 예외: 반드시 작성해야 컴파일 가능
- 실행 예외: 컴파일러가 체크해주지 않으며 개발자 경험 의해 작성

- 실행문에서 발생한 예외를 처리하는 코드를 말합니다.
- 예외 처리 코드가 실행되면 프로그램이 강제 종료 되지 않고 정상 작동합니다.

문법)

```
try{
	예외 발생 가능성 있는 실행문들 나열...
} catch(예외클래스 변수) {
	예외 클래스와 일치하는 예외 발생시 처리 코드
} [finally {
	try 또는 catch문 종류 후 반드시 실행해야 하는 코드 나열...(필요 없으면 생략 가능)
}]
```

```
String str = null;

try { //실행 코드들
	System.out.println("예외 발생 가능 코드 시작");
			
	//System.out.println(str.length());
			
	System.out.println("예외 발생 가능 코드 종료");
} catch(NullPointerException e) { //예외 처리 코드들
	System.out.println("str은 null입니다.");
} finally {
	System.out.println("예외가 발생했던 안했던 실행 할 겁니다.");
}
```

**1. 다중 catch문**  
- try 안에서 발생하는 다양한 최초 예외에 대하여 서로다른 예외처리를 하고자하는 경우 사용

문법)

```
try{
	
} catch(예외 클래스1 e) {
	예외1이 발생한 경우 실행 코드
} catch(예외 클래스2 e) {
	예외2가 발생한 경우 싫애 코드
}
...
* catch문 나열은 하위예외클래스 > 상위예외클래스 순으로 나열해야 합니다.
```

```
int[] arr = new int[5];
Scanner sc = new Scanner(System.in);

try {
	for(int i=0; i<=arr.length; i++) {
		System.out.print("정수 입럭> ");
		int value = Integer.parseInt(sc.nextLine());
		arr[i] = value;
	}
} catch(NumberFormatException e) {
	System.out.println("숫자를 입력하지 않았습니다.");
} catch(ArrayIndexOutOfBoundsException e) {
	System.out.println("존재하지 않는 인덱스입니다.");
} finally {
	System.out.println("try-catch 종료");
}
```

**2. 멀티 catch문**  
- try 안에서 발생하는 다양한 최초 예외에 대하여 같은 예외처리코드를 작성하고자 하는 경우 사용

문법)

```
try {
		 	
} catch(예외클래스1 | 예외클래스2 | ... e) {
	
}
* catch문 나열은 하위예외클래스 > 상위예외클래스 순으로 나열해야 합니다.
		 
e.printStackTrace(); -> 발생한 예외에 대한 메시지를 콘솔에 출력하는 실행문
```

```
Scanner sc = new Scanner(System.in);

int num1 = 0;
int num2 = 0;
		
int[] result = new int[3];
		
try {
	for(int i = 0; i<=result.length; i++) {
		System.out.print("숫자1> ");
		num1 = Integer.parseInt(sc.nextLine());
		System.out.print("숫자2> ");
		num2 = Integer.parseInt(sc.nextLine());
		
		result[i] = num1/num2;
		
		System.out.println("결과 값> "+result[i]);
	}
} catch(NumberFormatException | ArithmeticException | ArrayIndexOutOfBoundsException e) {
	System.out.println("예외 발생");
	e.printStackTrace();
}
```

```
//*가장 많이 사용하는 예외 처리 구조*
try {
			
} catch(Exception e) { //모든 종류의 최초 예외 처리
	e.printStackTrace();
} finally {
			
}
```

**3. 리소스 자동 닫기 try-with-resource**  
- 사용한 외부 자원 객체를 자동으로 닫아주는 문법

문법)

```
try(자원 변수 = 자원 객체; ...) {
 	
} catch(Exception e) {
	e.printStackTrace();
}
```

```
try(Scanner sc2 = new Scanner(System.in); Scanner sc3 = new Scanner(System.in);){
	System.out.println("실행문1");
	System.out.println("실행문2");
	System.out.println("실행문3");
} catch(Exception e) {
	e.printStackTrace();
}
```

**4. 예외 떠넘기기**  
- 예외가 발생한 코드가 아닌 예외 발생 코드를 호출한 곳에서 처리하도록 유도하는 방법 입니다.
- throws 키워드를 사용합니다.

문법) 메소드() throws 예외클래스1, 예외클래스2, ...{}

```
//Sample1.class

public void method1() throws Exception {	
	System.out.println(10/0);
	
}
```

```
//Main.class

Sample1 sample1 = new Sample1();
		
try {
	sample1.method1();	
} catch(Exception e) {
	e.printStackTrace();
}
System.out.println("프로그램 종료");
```

**5. 예외 발생하기**  
- 강제로 해당 예외를 발생시키는 방법 입니다.
- throw 키워드를 사용합니다.

문법) throw new 예외클래스();

사용예)
- 예외 처리에 대한 디버깅
- 외부 공격 등 강제로 시스템 종료해야하는 경우