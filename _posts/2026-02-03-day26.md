---
title: 2026.02.03 java 기초(13)
date: 2026-02-03
categories: [국비교육]
tags: [java]
---

### 날짜 정보 관련 클래스

#### Date 클래스

```
Date todayDate = new Date(); //현재 시간 정보 객체
System.out.println(todayDate);
		
SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd");
System.out.println(simpleDateFormat.format(todayDate));
```

#### Calendar 클래스

```
Calendar calendar = Calendar.getInstance(); //객체 생성 X, 싱글톤 객체 사용
		
int year = calendar.get(Calendar.YEAR); //년도 정보
System.out.println("연도 : "+year);
int month = calendar.get(Calendar.MONTH)+1; //월 정보 (0부터 1월로 시작)
System.out.println("월 : "+month);
int day = calendar.get(Calendar.DAY_OF_MONTH); //일 정보
System.out.println("일 : "+day);	
	
int week = calendar.get(Calendar.DAY_OF_WEEK); //요일 정보
System.out.println("요일 : "+week);
System.out.println("화요일 : "+Calendar.TUESDAY);
switch(week) {
	case Calendar.MONDAY :
		System.out.println("월요일");
		break;
	case Calendar.TUESDAY :
		System.out.println("화요일");
		break;
 	case Calendar.WEDNESDAY :
 		System.out.println("수요일");
 		break;
	case Calendar.THURSDAY :
 		System.out.println("목요일");
 		break;
	case Calendar.FRIDAY :
 		System.out.println("금요일");
 		break;
	case Calendar.SATURDAY :
 		System.out.println("토요일");
 		break;
	case Calendar.SUNDAY :
  		System.out.println("일요일");
 		break;
	default :
}
 		
int amPm = calendar.get(Calendar.AM_PM); //오전오후 정보
System.out.println("오전/오후 : "+amPm);
if(amPm == Calendar.AM) {
	System.out.println("오전");
} else {
	System.out.println("오후");
}

int hour = calendar.get(Calendar.HOUR); //시 정보
System.out.println("시 : "+hour);	
int minute = calendar.get(Calendar.MINUTE); //분 정보
System.out.println("분 : "+minute);
int second = calendar.get(Calendar.SECOND); //초 정보
System.out.println("초 : "+second);	
```

#### LocalDateTime 클래스
 - 날짜 객체를 제공하며 여러 기능들을 사용하여 날짜 조작을 할 수 있습니다.
 - 특정 날짜 객체를 제공 받을 수 도 있습니다.

```
LocalDateTime local = LocalDateTime.now();
System.out.println(local);
 		
DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"); //LocalDateTime의 문자열 날짜 포맷 지정
System.out.println(local.format(dtf));
		
LocalDateTime result1 = local.minusYears(1);
System.out.println(result1.format(dtf));
 		
result1 = local.minusDays(50);
System.out.println(result1.format(dtf));

LocalDateTime startDay = LocalDateTime.of(2026, 1, 1, 0, 0, 0);
LocalDateTime endDay = LocalDateTime.of(2026, 2, 1, 0, 0, 0);
 		
long day2 = startDay.until(endDay, ChronoUnit.DAYS); //날짜를 지정하여 일수 차 구하기
System.out.println("day2 : "+day2);
```

### 문자열 형식과 관련된 클래스
문자열 형식이란 정해진 패턴의 문자열을 의미하며 포맷이라고 부릅니다.

#### DecimalFormat 클래스
- 숫자와 관련된 문자열 형식을 만드는 클래스입니다.

```
DecimalFormat df = new DecimalFormat("#.0");
		
double number1 = 3.12345;
System.out.println(df.format(number1)); //3.1
System.out.println(df.format(3)); //3.0
		
DecimalFormat df2 = new DecimalFormat("#,###");
System.out.println(df2.format(100000)); //100,000
System.out.println(df2.format(100)); //100
```


## 제네릭
제네릭이란,
- 컴파일시 객체 필드 또는 매개변수등 객체 내부의 강력한 타입 컴파일체크를 위하여 사용하는 구문입니다.
- 객체가 생성될 때 객체마다 각각 다른 타입의 필드 매개변수를 갖기위하여 Object 타입으로 선언하는 경우 강제 형변환 시 잘못된 자식 타입으로 인하여 실행시 발생하는 예외를 예방하기 위하여 사용합니다.
- 클래스 선언시가 아니라 객체 생성시 타입을 결정하는 방법입니다.
- 객체 생성시 타입을 결정하기 때문에 타입이 맞지 않으면 컴파일 오류가 발생하고 실행시 castException은 발생하지 않습니다.

```
//Sample2.class

public class Sample2 <A> { //클래스명 옆에 <> 선언, 생성될 때 타입을 받음
	public A o;	
}
```

```
//Main.class

//Sample2<String> sample2 = new Sample2<Integer>(); 클래스 변수의 타입과 생성자의 타입 변수 값이 일치하지 않아서 오류
Sample2<String> sample2 = new Sample2<String>();
//sample2.o = 10; 제네릭으로 전달한 String 타입은 o 필드의 데이터 타입이므로 int는 대입 X
sample2.o = "A";
		
Sample2<String[]> sample3 = new Sample2<String[]>();
sample3.o = new String[]{"A"};
		
String[] strs = sample3.o;
String str = sample2.o;
```

```
//Calculator.class

public class Calculator <A> {
	/*
	오류!
	타입 파라미터 변수로 어떤 타입이 대입될 지 알 수 없으므로
	산술연산자 +기호를 타입파라미터를 갖는 변수와 연산할 수 없습니다.
	*/
	public A oper(A arg1, A arg2) {
		return arg1+arg2;
	}
}
```

```
//Main.class

Calculator<Integer> calc = new Calculator<Integer>();
int result3 = calc.oper(10, 10);
System.out.println(result3); //20출력

Calculator<String> calc = new Calculator<String>();
String result5 = calc.oper("hello", "java");
System.out.println(result5); //"hellojava"출력
```

#### 타입 파라미터를 여러개 갖는 클래스 객체 생성하기

```
//MySystem.class

public class MySystem <T,V>{
	public T t;
	public V v;
}
```

```
//Main.class

MySystem<String, Integer> my1 = new MySystem<String, Integer>();
my1.t = "10";
my1.v = 10;

//타입파라미터를 전달하지 않는 경우 기본 타입은 Object로 초기화 됩니다.
MySystem my3 = new MySystem(); 
```

#### 인터페이스에 타입 파라미터가 있는 경우
인터페이스는 객체가 될 수 없으므로 구현 클래스에서 타입 파라미터를 받아 인터페이스의 타입을 결정해야합니다.

```
//SampleService.interface

public interface SampleService <T> {
	void method(T t);
}
```

```
//SampleImpl.class

public class SampleImpl<T> implements SampleService<T>{
	@Override
	public void method(T t) {
		System.out.println(t.toString());
	}
}
```

```
//Main.class

//SampleService<Integer> sample1 = new SampleImpl<String>();
/*
 현재 sample1 인터페이스는 Integer 타입의 매개변수를 갖는
 method를 정의한 구현 객체만 대입할 수 있습니다.
 */
		
SampleService<String> sample1 = new SampleImpl<String>();
//sample1.method(10); 매개값이 String 타입인 경우만 호출 가능
sample1.method("A");
```

#### 제네릭 메소드 호출
- 클래스의 타입 파라미터 변수명과 제네릭 메소드의 타입 파라미터 변수명이 같다면	각각의 영역에서의 타입을 우선으로 사용합니다.
- 되도록 파라미터 변수명이 중복되지 않도록 사용하는 것이 가독성에 좋습니다.

```
//Sample2.class

public class Sample2 <A> {
	public A o;
	
	//public static A o2; 클래스의 타입파라미터는 객체가 생성되는 시점에 결정되므로 정적멤버에는 사용할 수 없습니다. 
	
	public static <T> void staticMethod(T t) { //타입파라미터를 메소드 호출시 결정하는 제네릭 메소드 선언
		System.out.println("Sample2의 정적 메소드");
		T t2 = t;
		System.out.println(t2.toString());
	}
	
	public <A> A method2(A t) {
		return t;
	}

}
```

```
//Main.class

Sample2.<String>staticMethod("A"); //<타입>메소드명() 으로 호출
		
//Sample2.<Integer>staticMethod("A"); Integer 타입으로 호출 했으므로 문자열 매개값을 넘길 수 없습니다.

Sample2 sample2 = new Sample2();
System.out.println(sample2.<Double>method2(3.14));

//왼쪽 변수 타입으로 오른쪽의 타입이 결정될 수 있다면 <>타입을 생략하여 작성할 수 있습니다.
Sample2<Person> sample4 = new Sample2<>();
		
//왼쪽 변수 타입으로 오른쪽 메소드의 타입파라미터가 결정될 수 있다면 <> 생략하여 작성할 수 있습니다.
//String result3 = sample4.method2(0); 변수 타입이 String이므로 타입파라미터는 String이 들어온다. 
String result3 = sample4.method2("A"); 
```