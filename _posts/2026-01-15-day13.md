---
title: 2026.01.15 데이터베이스 기초(4)
date: 2026-01-15
categories: [국비교육]
tags: [database, mysql]
---

#### LIMIT

```
LIMIT 20 OFFSET 10; --10번째 이후부터 20개
LIMIT 10, 20; -- 10번째 이후부터 20개
```


## 윈도우 함수

#### 순위 매기는 함수

```
SELECT
	 row_number() OVER (ORDER BY p.prod_untprc DESC) AS `row` 
	 ,RANK() OVER (ORDER BY p.prod_untprc desc) AS `rank`
	 ,DENSE_RANK () OVER (ORDER BY p.prod_untprc desc) AS `dense_rank` 
	 ,PERCENT_RANK() OVER (ORDER BY p.prod_untprc desc) * 100 AS `percent_rank`
	 ,ntile(5) OVER (ORDER BY p.prod_untprc desc) AS `ntile` 
	 ,p.*
FROM
	products p;
```

- row_number() -- 중복된 값 상관 없이 순위 매김
- RANK() -- 중복된 값 포함 순위 매김
- DENSE_RANK() -- 중복된 값 포함 순위를 매기지만 순차적으로 순위를 매김
- PERCENT_RANK() -- 퍼센트로 계산하여 순위를 매기지만 연산을 통해서 계산도 가능
- NTILE() -- 순위를 n등분하여 표시 ex) 5등분 시 참고행을 100 기준 5등분하여(1등:1~20, 2등:21~40,...) 1~5등을 매김

#### 값 접근 함수

```
SELECT
	 lag(order_no, 2, '') OVER (ORDER BY o.order_no desc) AS `pre_row` 
	,lead(order_no, 1, '') OVER (ORDER BY o.order_no desc) AS `after_row` 
	,o.*
from
	orders o;
```

- LAG(컬럼, n만큼 이전 행 접근, null일 경우 변경될 값) 이전 행을 접근 
- LEAD(컬럼, n만큼 이후 행 접근, null일 경우 변경될 값) 이후 행을 접근 

#### 데이터 타입 변환 함수
CAST(데이터  AS 타입) <br>
CONVERT(데이터, 타입)

```
SELECT '2026-01-15'; -- 문자형
SELECT CAST('2026-01-15' AS date); -- 날짜형으로 변환
SELECT CAST('2026/01/05 11:16:40' AS  time); -- time형으로 변환
SELECT CAST('2026-01-15 11:16:40' AS datetime); -- datetime형으로 변환
SELECT cast('1' AS signed); -- int형은 cast로 변환할수 없는 타입이라, signed(부호가 있는 bigint 타입)를 사용하여 변환

SELECT CONVERT('2026/01/05 11:16:40', datetime);
SELECT convert('1', unsigned); -- int형은 cast로 변환할수 없는 타입이라, unsigned(부호가 없는 bigint 타입)를 사용하여 변환
SELECT convert(1, char); -- 숫자형을 문자형으로 변환
```

- 조회되는 데이터의 타입을 함수
- int형은 cast로 변환할수 없는 타입이라, signed(부호가 있는 bigint 타입)이나 unsigned(부호가 없는 bigint 타입)를 사용하여 변환

#### 문자열 연결 함수
CONCAT(문자열1, 문자열2)

```
SELECT concat('가', '나');

SELECT 
	 CONCAT(m.mbr_id, ' : ',m.mbr_name, ' : ', m.mbr_email)
	,CONCAT_WS(' : ', m.mbr_id , m.mbr_name , m.mbr_email )
	,CONCAT(1,2,3)
	,concat_ws(' : ', 1,2,3)
FROM
	members m;
```

CONCAT_WS('중복되는 구분자', 데이터, ...) 데이터와 데이터 사이 구분자가 중복될 때 concat_ws를 사용하여 간단하게 적을 수 있다.

#### 문자열 내 추출 함수
SUBSTRING(데이터, 시작인텍스(1부터 시작), 추출할 갯수)

```
SELECT SUBSTRING('문자열', 1, 2);

SELECT SUBSTRING_INDEX('ksmartid1 : 홍01 : ksmartid1@ksmart.or.kr', ' : ', -2);

SELECT
	 SUBSTRING_INDEX(m.mbr_email, '@', 1) AS id
	,substring_index(
		 SUBSTRING_INDEX(m.mbr_email, '@', -1)
		, '.'
		, 1
	) AS email_domain
FROM
	members m;
```

- substring_index(데이터, 구분자, 양수(왼쪽부터 n만큼) | 음수(오른쪽부터 n만큼)) : 구분자를 기준으로 앞/뒤를 추출
- substring_index는 중첩하여 호출할 수 있다. (단 집계 함수는 중첩해서 호출할 수 없다.)

#### 문자열 함수

```
SELECT ASCII('A'), CHAR(65); //ASCII 코드변환
SELECT TRIM(' KSMART58 ') AS `result`; //TRIM 앞뒤 공백제거
SELECT REPEAT('KSMART', 3) AS `result`; //REPEAT 데이터 반복 출력
SELECT REPLACE ('KSMART58기', 'KSMART' , '한국스마트정보교육원') AS `result`; //REPLACE 데이터 변경
```

#### 묵시적 형변환 주의

```
SELECT '100' + '200' ; //문자와 문자를 더함 (정수로 변환되서 연산됨)
SELECT CONCAT('100', '200'); //문자와 문자를 연결 (문자로 처리)
SELECT CONCAT(100, '200'); //정수와 문자를 연결 (정수가 문자로 변환되서 처리)
SELECT 1 > '2mega'; //정수인 2로 변환되어서 비교
SELECT 0 = 'mega2'; //문자는 0으로 변환됨
```

#### 제어 흐름 함수
IF(조건식, 참일경우 반환데이터, 거짓일경우 반환데이터)

```
SELECT IF(10>20, 'true', 'false');
```

IFNULL(데이터, 데이터가 NULL일 경우 반환되는 데이터)

```
SELECT IFNULL(NULL, ''), IFNULL(100, '널');
```

NULLIFF(데이터1, 데이터2) 데이터1, 데이터2 비교 연산 후 참: NULL반환, 거짓: 데이터1 반환

```
SELECT NULLIF(10,10), NULLIF(30,10);
```

CASE 타깃값 WHEN 값 THEN 값과 일치시 반환될 데이터 ELSE 불일치시 반환되는 데이터

```
SELECT
   CASE 3
   WHEN 1 THEN '일'
   WHEN 3 THEN '삼'
   WHEN 5 THEN '오'
   ELSE NULL
   END AS 'CASE 구문';
```

#### 날짜 연산 함수
ADDDATE(날짜, INTERVAL 연산데이터 DAY|MONTH|YEAR) <br>
SUBDATE(날짜, INTERVAL 연산데이터 DAY|MONTH|YEAR)

```
SELECT 
   ADDDATE('2026-01-18', INTERVAL 31 DAY),
   ADDDATE('2026-01-18', INTERVAL 1 MONTH);
SELECT 
   SUBDATE('2026-01-18', INTERVAL 31 DAY),
   SUBDATE('2026-01-18', INTERVAL 1 MONTH);

SELECT 
   ADDTIME('2026-01-18 23:59:59', '1:1:1'),
   ADDTIME('15:00:00', '2:10:10');
SELECT 
   SUBTIME('2026-01-18 23:59:59', '1:1:1'), 
   SUBTIME('15:00:00', '2:10:10');
```

ADDTIME(일시, '시:분:초') <br>
SUBTIME(일시, '시:분:초')

```
SELECT 
   ADDTIME('2026-01-18 23:59:59', '1:1:1'),
   ADDTIME('15:00:00', '2:10:10');
SELECT 
   SUBTIME('2026-01-18 23:59:59', '1:1:1'), 
   SUBTIME('15:00:00', '2:10:10');
```

DATEDIFF( 날짜1, 날짜2) 날짜1 – 날짜2 <br>
TIMEDIFF( 시간1, 시간2) 시간1 – 시간2

```
SELECT 
   DATEDIFF('2025-01-06', NOW()),
   TIMEDIFF('17:30:01', CURRENT_TIME());

SELECT 
   DAYOFWEEK(CURDATE()),
   MONTHNAME(CURDATE()),
   DAYOFYEAR(CURDATE());

SELECT LAST_DAY('2025-02-18');
```

#### 변수 선언 키워드
SET

```
SET @num := 123;

SELECT @num := @num + 100;

SELECT @num;
```

초기화를 안하고 실행하면 계속 연산하여 데이터 값 반환


## 데이터 베이스 설계
사용자의 다양한 요구사항을 고려하여 데이터 베이스를 생성하는 과정

1. 요구사항 : 데이터베이스의 용도 파악 ( 요구사항 명세서 )
2. 개념적 설계 : DBMS에 독립적인 개념적 구조 설계 ( E-R 다이어그램 )
3. 논리적 설계 : DBMS에 적합한 논리적 구조 설계 ( 릴레이션 스키마 )
4. 물리적 설계 : DBMS에 구현 가능한 물리적 구조 설계 ( 물리적 스키마 )
5. 구현 : 데이터베이스 생성

#### 요구사항

목적
- 사용자의 요구 사항을 수집 분석하여 개발할 데이터베이스의 용도 파악
- 업무에 필요한 데이터? 데이터를 이용하여 어떻게 처리? 등 고려
- 결과물 :  요구사항명세서

주요작업
- 데이터베이스를 실제로 사용할 사용자의 범위를 결정
- 사용자가 조직에서 수행하는 업무를 분석
- 면담, 설문조사, 업무관련 문서 분석 등의 방법을 이용해 요구 사항 수집
- 수집된 요구 사항에 대한 분석 결과를 요구사항명세서로 작성

#### 개념적 설계

목적
- DBMS에 독립적인 개념적 스키마 설계
- 요구사항 명세서를 개념적 구조로 표현
- 결과물 :  E-R 다이어그램

주요작업
- 요구사항 분석 결과를 기반으로 주요한 개체를 추출하고 개체간의 관계를 결정
- 결정된 내용을 기반으로 E-R 다이어 그램으로 표현

개체와 속성 추출
- 저장할만한 가치가 있는 중요 데이터를 가진 사람이나 사물

개체 추출 방법
- 요구 사항 내용에서 업무와 관련이 깊은 의미 있는 명사
- 업무와 관련이 적은 일반적이고 광범위한 의미의 명사는 제외
- 의미가 같은 명사가 여러 개일 경우는 대표 명사 하나만 선택
- 추출된 명사를 개체와 속성으로 분류

#### 논리적 설계

목적
- DBMS에 적합한 논리적 스키마 설계
- 개념적 스키마 → 논리적 구조 
- 결과물 : 릴레이션 스키마

주요작업
- E–R 다이어그램을 릴레이션 스키마 변환
- 릴레이션 스키마 변환 후 속성의 데이터 타입, 길이, 널 값 허용 여부, 기본 값, 제약조건 등을 세부적으로 결정하고 결과를 문서화시킴

E-R 다이어그램 -> 릴레이션 스키마 변환 규칙
1. 모든 개체는 릴레이션으로 변환
2. 다대다 관계는 릴레이션으로 변환 
- 관계에 참여하는 개체를 규칙1에 따라 릴레이션으로 변환한 후 이 릴레이션의 기본키를 관계 릴레이션에 포함시켜 외래키로 지정하고 외래키들을 조합하여 관계 릴레이션의 기본키로 지정
3. 일대다 관계는 외래키로 표현
- 일대다 관계에서 일측 개체 릴레이션의 기본키를 다측 개체 릴레이션에 포함
- 관계의 속성들도 다측 개체 릴레이션에 포함시킴
- 약한개체가 참여하는 일대다 관계는 외래키를 포함해서 기본키로 지정
- 다측 개체 릴레이션은 외래키를 포함하여 기본키를 지정
- 약한 개체는 주 개체에 따라 존재 여부가 결정되므로 주 개체의 기본키를 포함해서 기본키 지정
- 강한개체 타입 : 자기 자신의 애트리뷰트 만으로 키를 명세할 수 있는 개체타입
- 약한개체 타입 : 자기 자신의 애트리뷰트 만으로 키를 명세할 수 없는 개체타입
4. 일대일 관계는 외래키로 표현
5. 다중 값 속성은 릴레이션으로 변환
- 다중 값을 가지는 속성일 경우 새로운 릴레이션을 생성한다
- 개체의 기본키를 새로운 릴레이션의 외래키로 설정한다.
- 지키지 않을 시 속성이 가질 수 있는 값은 원자값이므로 자칫 불필요한 속성이 생겨 비효율적일 수 있다.
