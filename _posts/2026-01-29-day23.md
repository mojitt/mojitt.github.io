---
title: 2026.01.29 데이터베이스 기초(6)
date: 2026-01-29
categories: [국비교육]
tags: [database, mysql]
---

## 정규화
데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법이며 데이터를 분해하는 과정.
즉 이상현상이 발생하는 릴레이션을 분해하는 과정.

## 이상현상
- 불필요한 데이터 중복으로 인해 릴레이션에 대한 데이터 삽입 수정 삭제 연산을 수행할 때 발생할 수 있는 부작용
- 삽입이상, 갱신(수정)이상, 삭제이상

#### 삽입이상 (Insertion Anomaly)
- 릴레이션에 새 데이터를 삽입하려면 불필요한 데이터도 삽입해야되는 문제
- ex) 회원가입시 불필요한 NULL 값을 삽입해야하는 문제

#### 갱신이상 (Update Anomaly)
- 릴레이션의 중복된 튜플 중 일부만 수정하여 데이터가 불일치하게 되는 모순이 발생되는 문제
- ex) 회원정보 수정시 등급의 데이터가 불일치되는 일관성 문제 발생

#### 삭제이상 (Deletion Anomaly)
- 릴레이션에서 튜플을 삭제하면 꼭 필요한 데이터까지 손실되는 연쇄 삭제 현상이 발생하는 문제
- ex) 회원등급을 삭제시 고객의 정보, 이벤트정보까지 연쇄 삭제되는 이상문제

#### 정규화 (Normalization)
- 이상 현상이 발생하지 않도록, 릴레이션을 관련 있는 속성들로만 구성하기 위해 릴레이션을 분해하는 과정
- 함수적 종속성을 판단하여 정규화를 수행

## 함수적 종속성 (Functional Dependency)
- 속성들 간의 관련성
- 함수 종속성을 이용하여, 릴레이션을 연관성이 있는 속성들로만 구성되도록 분해하여 이상현상이 발생하지 않는 릴레이션으로 만들어가는 과정

#### 함수 종속 관계 판단
- 속성 자체의 특성과 의미를 기반으로 함수 종속성을 판단.
- 속성 값은 계속 변할 수 있으므로 현재 릴레이션에 포함된 속성 값만으로 판단하면 안됨.
- 일반적으로 기본키와 후보키는 릴레이션의 다른 모든 속성들을 함수적으로 결정함.
- 기본키나 후보키가 아니어도 다른 속성 값을 유일하게 결정하는 속성은 함수 종속관계에서 결정자가 될 수 있음.
  
함수 종속 관계 판단시 고려대상이 아닌 경우
- 결정자와 종속자가 같거나, 결정자가 종속자를 포함하는 것처럼 당연한 함수 종속관계는 고려하지 않음

#### 완전 함수 종속
- 릴레이션에서 속성 집합 Y가 속성집합 X에 함수적으로 종속되어 있지만, 속성 집합 X의 전체에 종속되어 있음
- 일반적으로 함수 종속은 완전 함수 종속을 의미함

#### 부분 함수 종속
- 릴레이션에서 속성 집합 Y가 속성 집합 X의 전체가 아닌 일부분에도 함수적으로 종속됨을 의미 

#### 제 1차 정규형 (1NF)
릴레이션의 속성값은 원자값
- 릴레이션의 모든 속성이 더는 분해되지 않는 원자값
  
1. 반복 집합이 있는 비정규 릴레이션
2. 반복집합을 제거함
3. 모든속성값이 원자값으로 구성된 제1정규형 릴레이션

#### 제 2차 정규형 (2NF)
기본키에 완전함수 종속
- 릴레이션이 제 1정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 완전함수 종속
  
1. 모든 속성값이 원자값으로 구성된 제1정규형 릴레이션
2. 부분 함수의 종속성을 제거
3. 모든 속성이 키에 완전함수 종속인 제2정규형 릴레이션

#### 제 3차 정규형 (3NF)
이행적 함수종속 제거
- 릴레이션이 제 2 정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속되지 않음.
  
1. 모든 속성이 키에 완전함수 종속인 제2정규형 릴레이션
2. 이행적 함수의 종속성을 제거
3. 키에 대해서 직접으로 함수종속하는 제3정규형 릴레이션

#### 보이스코드 정규형 (BCNF)
모든 결정자가 후보키
- 릴레이션이 제 3 정규형에 속하고, 릴레이션에 존재하는 함수 종속성에서 모든 결정자가 후보키인 릴레이션
  
1. 키에 대해서 직접으로 함수종속하는 제3정규형 릴레이션
2. 후보키 집합에 없는 속성이 결정자가 되는 속성 제거
3. 모든 결정자가 후보키인 BCNF 릴레이션

#### 그 외 정규형
제 4 정규형
- 릴레이션이 보이스/코드 정규형을 만족하면서, 함수 종속이 아닌 다치 종속을 제거한 릴레이션

제 5 정규형
- 릴레이션이 제 5 정규형을 만족하면서, 후보키를 통하지 않는 조인 종속을 제거한 릴레이션

정규화 시 주의사항
- 모든 릴레이션이 제 5 정규형에 속해야만 바람직한 것은 아님
- 정규화를 많이 거칠 수록 중복은 줄일 수 있으나 성능에 영향을 미침 (조인 연산)
- 일반적으로 제 3 정규형이나 보이스/코드 정규형에 속하도록 릴레이션을 분해하여 데이터 중복을 줄이고 이상 현상을 해결하는 경우가 많음 (실무)

#### 반정규화(역정규화)
의도적으로 정규화 원칙을 위배하는 행위로 데이터베이스 성능향상을 위해, 데이터 중복을 허용하고 조인을 줄이는 데이터베이스 성능향상방법

대상
- 수행 속도가 많이 느린경우, 테이블의 조인 연산을 지나치게 사용하여 데이터를 조회하는 것이 기술적으로 어려운 경우, 테이블에 많은 데이터가 있고, 다량의 범위 혹은 특정 범위를 자주 처리하는 경우

장점
- 데이터를 빠르게 조회, 조인을 제거하기 때문에 검색 시간이 최적화

단점
- 데이터의 삽입, 삭제, 수정 등 갱신 시 비용이 높아짐
- 데이터간의 일관성이 깨질 수 있고, 많은 저장 공간이 필요함 (예시: 테이블의 열이 증가)



## 서브쿼리 (Sub Query)
하나의 SQL 문에 포함되어 있는 또 다른 SQL문

주의사항
- 서브쿼리는 괄호를 감싸서 작성한다
- 서브쿼리는 단일 행 또는 복수 행 비교 시 그에 맞는 연산자와 함께 사용한다
- 서브쿼리에서는 order by를 사용하지 못한다 (데이터 반환이 목적이지 정렬은 의미없다) but, MySQL에서는 지원함.

서브쿼리를 사용할 수 있는 곳
- SELECT 절, FROM 절, WHERE 절, HAVING 절, ORDER BY 절, INSERT VALUE 절, UPDATE SET 절

#### 서브쿼리의 종류
- 스칼라 서브쿼리
	- SELECT절에 있는 서브쿼리 (단일행만 반환)
- 인라인 뷰
	- FROM절에 있는 서브쿼리
- 서브쿼리
	- WHERE절에 있는 서브쿼리

```
-- 서브쿼리
SELECT
	p.*
FROM 
 	products p
WHERE
	p.prod_untprc > ( 
	 					SELECT 
	 						avg(sub_p.prod_untprc)
	 					FROM
	 					 	products sub_p
					);


-- 인라인뷰
SELECT
	*
FROM 
 	products p 
 	INNER JOIN  
 	(
 		SELECT
 			 vend_cd 
 			,vend_telno 
 		FROM
 		 	vendors
 	) v
 	USING (vend_cd);


-- 스칼라 서브쿼리
SELECT
	p.vend_cd 
	,(
		SELECT
			v.vend_telno 
		FROM 
			vendors v
		WHERE 
			v.vend_cd = p.vend_cd
	 ) AS '담당자연락처'
FROM
 	products p;
```

#### 다중 행 연산자
서브쿼리 결과가 다중행일 경우 반드시 다중행 비교연산자로 작성

연산자 종류
- IN : 리턴되는 값 중에서 조건에 해당하는 값이 있으면 참
- ANY, SOME : 서브쿼리에 의해 리턴되는 각각의 값과 조건을 비교하여 하나 이상을 만족하면 참
- ALL : 값을 서브쿼리에 의해 리턴되는 모든 값과 조건 값을 비교하여 모든 값을 만족해야만 참
- EXISTS : 메인 쿼리의 비교 조건이 서브쿼리의 결과 중에서 만족하는 값이 하나라도 존재하면 참

```
-- IN (OR)
-- 동등 비교

SELECT
	*
FROM 
	members m 
WHERE
	m.mbr_id IN ('ksmartid1', 'ksmartid2');

SELECT
	*
FROM 
	members m
WHERE 
	m.mbr_id IN (
				SELECT DISTINCT 
					o.cust_id 
				FROM
					orders o
			 );
```

```
-- ANY, SOME : 서브쿼리의 반환값만 가능, 직접 값을 입력은 불가, 비교연산자와 같이 사용 (OR 동일)
-- any나 some이나 똑같음

SELECT
	*
FROM
	products p 
WHERE
	-- p.prod_untprc > 50000 or p.prod_untprc > 100000 or p.prod_untprc > 200000
	p.prod_untprc > ANY (
							SELECT
								p2.prod_untprc  
							FROM
								products p2 
							WHERE
								p2.prod_cd IN ('prod_1', 'prod_3', 'prod_4') 
						);
```

```
-- ALL : 서브쿼리의 반환값만 가능, 직접 값을 입력은 불가, 비교연산자와 같이 사용 (AND 동일)

SELECT
	*
FROM
	products p 
WHERE
	-- p.prod_untprc > 50000 and p.prod_untprc > 100000 and p.prod_untprc > 200000
	p.prod_untprc > All (
							SELECT
								p2.prod_untprc  
							FROM
								products p2 
							WHERE
								p2.prod_cd IN ('prod_1', 'prod_3', 'prod_4') 
						);
```

```
-- EXISTS : 서브쿼리의 결과 행이 존재할 경우 조회

SELECT
	*
FROM 
	members m 
WHERE
EXISTS
(
	SELECT
		*
	FROM
		orders o
	WHERE
		o.cust_id = m.mbr_id
);
```
