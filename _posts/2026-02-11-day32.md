---
title: 2026.02.11 java 기초(15)
date: 2026-02-11
categories: [국비교육]
tags: [java]
---

#### List 인터페이스

```
/*
isEmpty()
- 컬렉션에 원소가 없으면 true, 있으면 false 를 반환하는 메소드
- 구현객체는 있으나 원소가 없는 경우 사용, null 에서 사용하면 예외 발생
*/
List<Integer> iList = new ArrayList<Integer>();
		
if(iList.size() == 0) {
	System.out.println("iList 원소 없음");
}
if(iList.isEmpty()) {
	System.out.println("iList 원소 없음");
}



/*
contains(Object o)
- 매개변수 o가 컬렉션에 있으면 true, 없으면 false 반환
*/
List<String> sList = new ArrayList<String>();
		
sList.add("A");
sList.add("B");
sList.add("C");

if(sList.contains("A")) {
	System.out.println("A 존재");
}
if(sList.contains("D")) {
	System.out.println("D 존재"); //출력x
}



/*
remove()
- 원소 하나씩 제거
*/
sList = new ArrayList<String>();

sList.add("A");
sList.add("B");
sList.add("C");
sList.add("D");
sList.add("D");
		
//일치 인덱스 제거 (일치하는 인덱스 원소 제거 후 제거 원소 값 반환합니다.)
System.out.println("제거 전 : "+sList.get(2));
String removeElement = sList.remove(2); //인덱스로 제거
System.out.println("제거 후 : "+sList.get(2)+", 제거 원소 값 : "+removeElement);
//제거 후 뒷 원소들을 앞으로 한칸씩 인덱스 당겨서 빈칸 없이 관리합니다.
		
//일치 원소 제거 (일치하는 가장 첫번째 원소를 제거 후 결과 boolean 타입으로 반환합니다.)
System.out.println("제거 전 : "+sList);
boolean removeResult = sList.remove("D");
System.out.println("제거 후 : "+sList+", 제거 결과 : "+removeResult);
removeResult = sList.remove("C");
System.out.println("제거 후 : "+sList+", 제거 결과 : "+removeResult);

iList = new ArrayList<Integer>();
		
iList.add(1);
iList.add(2);
iList.add(3);
iList.add(4);
iList.add(5);
		
//만약 int 타입의 경우 원소로 제거하고 싶으면 박싱을 해서 제거해야 합니다.
iList.remove(2);
iList.remove(new Integer(2));
System.out.println(iList);
		
		
		
/*
clear()
- 원소 전부 제거
*/
iList.clear();
System.out.println(iList);
```


#### Set 인터페이스
Set 인터페이스에 대하여 살펴보기
- 집합 구조로 순서없이 데이터를 관리하는 컬렉션 입니다.
- 순서가 유지 되지 않기 때문에 중복 데이터를 허용x, null도 한번만 대입 가능
		
구현 클래스
- HashSet
- TreeSet (주로 독단적으로 사용하는 클래스)

```
Set<String> set; //문자열 데이터 집합을 관리하는 인터페이스 선언
set = new HashSet<String>(); //빈 보따리

//원소 추가 : add() 사용		
boolean result;
result = set.add("A");
System.out.println("대입 결과 : "+result); //true
result = set.add("B");
System.out.println("대입 결과 : "+result); //true
result = set.add("C");
System.out.println("대입 결과 : "+result); //true
result = set.add("A"); //같은 데이터이므로 set에 추가x
System.out.println("대입 결과 : "+result); //false
		
System.out.println(set); //[A,B,C]

//원소 갯수 : size() 사용
System.out.println("pSet2의 원소 갯수 : "+pSet2.size());
		
		
//집합 안의 모든 원소 접근하기
//1. 향상된 for 문 사용하기
//2. iterator() 사용하기 -> 반복자를 사용하여 토큰으로 모든 원소 접근 (재사용 x)
iSet = new HashSet<Integer>();
iSet.add(10);
iSet.add(2);
iSet.add(7);
iSet.add(6);
iSet.add(1);
		
for(int value : iSet) {
	System.out.println(value);
}
		
System.out.println("---------");
//반복자 Iterator 타입 객체를 사용하여 set 안의 모든 원소 한줄로 줄 세웁니다.
Iterator<Integer> iter1 = iSet.iterator();
while(iter1.hasNext()) { //.hasNext() 토큰 아래 데이터 여부 반환
	int value = iter1.next();
	System.out.println(value);
}

pIter = pSet.iterator();
while(pIter.hasNext()) {
	Person p = pIter.next();
			
	System.out.println("-------------");
	System.out.println(p.getJumin());
	System.out.println(p.getName());
	System.out.println(p.getAddress());
	System.out.println(p.getAge());
			
	//next()를 잘 못 사용하는 경우
	//한번의 반복에서 next()는 한번만 호출해야 가리키는 원소가 정확합니다.
	/*
	System.out.println("-------------");
	System.out.println(pIter.next().getJumin());
	System.out.println(pIter.next().getName());
	System.out.println(pIter.next().getAddress());
	System.out.println(pIter.next().getAge());
	*/
}

//contains(Object o) : set 안에 객체 존재 여부 true, false 반환
//isEmpty() : set 안에 원소 없는 경우 true, 있으면 false 반환
		
//remove(Object o) : 매개값 객체와 일치하는 원소 삭제 / 삭제 결과 boolean으로 반환
boolean result2 = pSet.remove(new Person("001", "", "", 0)); //hashCode와 equals가 재정의 되어있는 Person은 jumin 필드 값이 같은 객체 제거
System.out.println(result2);
for(Person value : pSet) {
	System.out.println(value.getJumin()+", "+value.getName());
}
		
//clear() : 전부 삭제
pSet.clear(); //HashSet 객체 제거가 아니라 빈 그릇으로 원소 갯수 0개로 만듭니다.
System.out.println(pSet.size());
```

#### Map
- 키, 값을 쌍으로 데이터를 관리하는 컬렉션
- 순서는 유지 되지 않습니다.
- 키로 값을 검색하는 용도로 사용
- 키값은 중복 x, 값 중복 o

```
Map<Integer, Integer> map1 = new HashMap<Integer, Integer>();

//put(키값, 값) : map에 데이터 추가
map1.put(1, 10);
map1.put(2, 20);
map1.put(3, 30);
map1.put(1, 40); //키 중복으로 이전 키 값을 40으로 덮어씌움
map1.put(4, 30); //키가 다르므로 값은 중복될 수 있습니다.
		
//size() : map의 원소 갯수
System.out.println("map1 갯수: "+map1.size()); //4
		
//get(키값) : 키와 일치하는 값 반환
System.out.println("키 1의 값: "+map1.get(1)); //40
```

보통 map의 키 타입으로는 String을 가장 많이 사용합니다.
- 이미 값이 같으면 동등객체 판별이 가능하도록 hashCode, equals 메소드가 재정의 되어 있으므로
- Integer를 키 타입으로 사용하지 않는 이유는 키의 의미를 담기에는 모호하기 때문에

```
//Map의 모든 원소 접근하기
		
//1. 모든 키 set을 활용하여 값에 접근하기
		
//map1의 모든 키
Set<Integer> map1Keys = map1.keySet();
		
//모든 키를 활용하여 값 접근하기 (향상된 for문 or Iterator)
for(int key : map1Keys) {
	System.out.println("-----------------");
	System.out.println("map1의 key: "+key);
	System.out.println("map1의 value: "+map1.get(key));
}
		
Iterator<Integer> map1KeyIter = map1Keys.iterator();
while(map1KeyIter.hasNext()) {
	int key = map1KeyIter.next();
	System.out.println("-----------------");
	System.out.println("map1의 key: "+key);
	System.out.println("map1의 value: "+map1.get(key));
}

//모든 원소 접근 : map의 원소 타입인 Map.Entery 객체를 전부 Set으로 가져와 반복 접근 하는 방법
Set<Map.Entry<Integer, Integer>> map1Entrys = map1.entrySet();
		
for(Map.Entry<Integer, Integer> entry : map1Entrys) {
	System.out.println("-----------------");
	System.out.println("map1의 key: "+entry.getKey());
	System.out.println("map1의 value: "+entry.getValue());
}
```