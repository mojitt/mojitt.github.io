---
title: 2026.02.23 javascript 기초(2)
date: 2026-02-23
categories: [국비교육]
tags: [javascript]
---

## 연산자

#### 산술연산자
- - +, -, *, /, %

```
const targetValue1 = 10;
const targetValue2 = 5;

let targetResult = targetValue1 + targetValue2;
console.log(`${targetValue1} + ${targetValue2} = ${targetResult}`);

targetResult = targetValue1 - targetValue2;
console.log(`${targetValue1} - ${targetValue2} = ${targetResult}`);

targetResult = targetValue1 * targetValue2;
console.log(`${targetValue1} * ${targetValue2} = ${targetResult}`);

targetResult = targetValue1 / targetValue2;
console.log(`${targetValue1} / ${targetValue2} = ${targetResult}`);

targetResult = targetValue1 % targetValue2;
console.log(`${targetValue1} % ${targetValue2} = ${targetResult}`);
```

#### 문자결합연산자
- '문자' + 1 , 1 + '문자' => 문자열 연결

```
console.log('가'+'나');
const responseNum = '2';
console.log(1+responseNum);
// 연산자는 같은 자료형끼리 연산한다.
// console.log(responseNum-1); 
// console.log(1+Number(responseNum));
```

#### 대입 연산자 및 복합 대입 연산자
- 일반적인 산술연산자를 간소화시켜 쓰는 방식
- =, +=, -=, *=, /=, %=

```
let exNum = 10; // 할당연산자

// 복합할당연산
exNum += 10; // exNum = exNum + 10
console.log(exNum); // 20
exNum -= 10; // exNum = exNum - 10
console.log(exNum); // 10
exNum *= 10; // exNum = exNum * 10
console.log(exNum); // 100
exNum /= 10; // exNum = exNum / 10
console.log(exNum); // 10
exNum %= 10; // exNum = exNum % 10
console.log(exNum); // 0
```

#### 증감연산자
- ++, --
- 전위(prefix): 먼저 증감 후 할당
- 후위(postfix): 먼저 할당 후 증감

```
let exResult = 0;
let x = 10;

exResult = x++; // 후위 : 선 할당 후 증가
console.log(`exResult: ${exResult}\nx: ${x}`); // 10 11
exResult = ++x; // 전위 : 선 증가 후 할당
console.log(`exResult: ${exResult}\nx: ${x}`); // 12 12
exResult = x--; // 후위 : 선 할당 후 감소
console.log(`exResult: ${exResult}\nx: ${x}`); // 12 11
exResult = --x; // 전위 : 선 감소 후 할당
console.log(`exResult: ${exResult}\nx: ${x}`); // 10 10
```

#### 비교연산자
- 두개의 데이터를 비교하여 결괏값을 논리형으로 받는다. 
- ==(값만 비교), ===(값과 타입모두 비교), !=, !==

```
console.log(`'10' == 10 결과: `, '10' == 10); // 값만 비교 : true
console.log(`'10' === 10 결과: `, '10' === 10); // 값과 타입 모두 비교 : false
console.log(`'10' != 10 결과: `, '10' != 10); // 값만 비교 : false
console.log(`'10' !== 10 결과: `, '10' !== 10); // 값과 타입 모두 비교 : true
console.log(`'true' == true 결과: `, 'true' == true); // 값과 타입 모두 비교 : false
console.log(`'true' === true 결과: `, 'true' === true); // 값과 타입 모두 비교 : false
```

#### 논리연산자
\- 2개 이상의 결괏값 혹은 비교연산자를 동시에 비교  
\- and(&&) -> 모두 참일 경우 참  
\- or(||) -> 하나라도 참이면 참  
\- not(!) -> 결괏값의 반대

```
const isBoolean1 = true;
const isBoolean2 = false;
const isBoolean3  = (3>=4); // false
const isBoolean4  = (3>=3); // true
console.log(`true || true 의 결과: ${isBoolean1 || isBoolean4}`); // true
console.log(`false || true 의 결과: ${isBoolean2 || isBoolean4}`); // true
console.log(`true && true 의 결과: ${isBoolean1 && isBoolean4}`); // true
console.log(`false && true 의 결과: ${isBoolean3 && isBoolean4}`); // false

console.log(`!isBoolean3 의 결과: ${!isBoolean3}`); // true
console.log(`!isBoolean4 의 결과: ${!isBoolean4}`); // false

// || 확장 -> 기본값으로 활용 (왼쪽항이 falsy면 우항을 반환)
const memberName = '' || '홍길동';
console.log(memberName); // 홍길동

// && -> 왼쪽항이 truthy면 우항값을 반환
const isLogin = true;
const memberId = isLogin && 'ksmartid1';
console.log(memberId); // ksmartid1

// && -> 조건문 if문 같이 활용
isLogin && console.log('ksmartid1님 로그인하셨습니다.');
```

#### 삼항조건연산자
- 조건식을 비교하여 참일 경우와 거짓일 경우 판별하여 각각의 값을 반환

```
const test = 50;
const passResult = (test >= 60) ? 'pass' : 'fail';
console.log(passResult); // fail

// 중첩 삼항연산자
const inputId = 'ksmartid1';
const inputPw = 'ksmartpw1';

const dbId = 'ksmartid1';
const dbPw = 'kspw1';

const loginMsg = (inputId === dbId) 
				? (inputPw === dbPw) 
					? `${inputId} 로그인하셨습니다.` : '비밀번호가 일치하지 않습니다.' 
				: '아이디가 존재하지 않습니다.';
console.log(loginMsg);
```

#### null 병합연산자
- 변수의 값이 null 또는 undefined일 경우 우항의 값으로 반환
- 변수(값)이 null이 아닌 경우는 변수에 담겨져있는 값 유지

- <pre>a || b : a가 falsy면 b (falsy: false, 0, "", null, undefined, NaN)</pre>
- a ?? b : a가 null 또는 undefined면 b (0이나 ""는 그대로 유지)

```
const value = null; // (undefined 동일)
const nullishValue = value ?? '우항의 값반환';
console.log(nullishValue);
```


## 조건문

#### if, else if, else
- 조건식이 참인 블록만 실행 (위에서 아래로 한 번만 매칭)
- else if는 개수 제한 없음
- 독립 if 여러 개는 "각각 따로" 실행될 수 있음

```
/**
  * if (조건식) {
  *   // statement 1
  * } else if (조건식) {
  *   // statement 2
  * } else {
  *   // statement 3
  * }
  */

// 독립 if: 여러 개가 동시에 실행될 수 있음
// if (조건식) console.log("A");
// if (조건식) console.log("B");

const isBoolean1 = true;
const isBoolean2 = false;
const strValue1 = '';
const strValue2 = '홍길동';
let undefinedValue;
const nullValue = null;

if(isBoolean1){
  console.log('true일 경우 해당 if블록 코드가 실행');
} else {
  console.log('false일 경우 해당 else 블록 코드가 실행');
}

const targetValue1 = 'C';
if(targetValue1 === 'A'){
  console.log('A');
}else if(targetValue1 === 'B'){
  console.log('B');
}else{
  console.log(targetValue1);
}
// 풀어서 작성
if(targetValue1==='A') console.log('A');
if(targetValue1==='B') console.log('B');
if(targetValue1!=='A' && targetValue1!=='B') console.log(targetValue1);
```

#### switch
- 하나의 값을 여러 case와 비교할 때 유용
- break가 없으면 아래 case로 "연속 실행(fall-through)" 됨
- default: 어떤 case도 매칭되지 않을 때

```
const targetValue2 = '가';
switch (targetValue2) {
  case '가':
    console.log('가');
    break;
  case '나':
    console.log('나');
    break;
  default:
    console.log('다');
    break;
}
  
switch (targetValue2) {
  // 가, 나 동일 코드 수행시
  // default는 필수가 아니다.
  case '가': case '나':
    console.log('가나');
    break;
}
```


## 반복문

#### while
- while(조건식) { ... } : 조건이 true인 동안 반복
- 반복 횟수가 정해져 있지 않을 때 유용 (ex. 입력이 올 때까지, 특정 상태까지)
- 주의: 증감/상태 변경이 없으면 무한 루프 발생

```
let whileCnt1 = 0;
while(whileCnt1 < 5){
    console.log(`${whileCnt1+1} 반복`);
    whileCnt1 += 1;
}
```

#### do..while
- do { ... } while(조건);
- 특징: 조건 검사 전에 do 블록을 먼저 1번 실행 (최소 1회 실행 보장)

```
const isPass = false;
// while vs do while
while(isPass){
    console.log('while 코드블록 실행');
}

do{
    console.log('do while 코드블록 실행');
} while(isPass);
```

#### for
- for(초깃값; 조건식; 증감식) { ... }
- 반복 횟수가 비교적 명확할 때 많이 사용
- let을 쓰면 블록 스코프라 for 밖에서 i 접근 불가(권장)
- (초깃값/조건/증감)은 필요하면 분리 가능

```
// var는 함수스코프 이므로 블록이 벗어나도 참조가 가능
for(var i=0; i < 2; i+=1){
    console.log(`for문 ${i+1}번 반복`);
}
console.log(i);

// let은 블록스코프 이므로 블록이 벗어나면 참조 불가능
for(let cnt=0; cnt < 2; cnt+=1){
    console.log(`for문 ${cnt+1}번 반복`);
}
//console.log(cnt); // cnt는 블록스코프 이므로 오류
```

#### break
- break를 만나면 가장 가까운 반복문/스위치를 즉시 종료
- 중첩 반복문에서 break는 "안쪽 반복문"만 종료함(기본 동작)

```
for(let x=0; x < 3; x+=1){
    for(let y=0; y < 3; y+=1){
        if(y == 1) break; // 가장 인접한 for문에서 빠져나온다.
        console.log(`break x: ${x}, y: ${y}`);
    }
}
```

#### continue
- continue를 만나면 현재 반복의 나머지 코드는 스킵하고 다음 반복으로 넘어감
- for에서 continue 이후에는 "증감식"으로 이동한다는 점이 포인트

```
for(let x=0; x < 3; x+=1){
    for(let y=0; y < 3; y+=1){
        if(y == 1) continue; // 다음 코드는 실행하지 않고 증감식으로 이동한다.
        console.log(`continue x: ${x}, y: ${y}`);
    }
}
```