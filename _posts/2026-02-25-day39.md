---
title: 2026.02.25 javascript 기초(4)
date: 2026-02-25
categories: [국비교육]
tags: [javascript]
---

## 객체
객체는 관련된 데이터(속성)와 기능(메서드)을 하나로 묶은 복합 자료형
- 속성(Property): 객체의 상태를 나타내는 값 (예: 이름, 나이, 색상)
- 메서드(Method): 객체가 수행할 수 있는 동작 (예: 걷기, 말하기, 계산하기)
- 객체는 참조 타입이므로 변수에는 객체의 실제 값이 아닌 메모리 주소가 저장됨.

- 추상화(Abstraction) : 객체의 공통적인 특성을 추출 / 복잡한 것을 단순화
- 캡슐화(Encapsulation) : 데이터와 기능을 하나로 묶고 외부 접근 제한 / 정보 은닉, 보안 강화
- 상속(Inheritance) : 기존 클래스의 속성과 메서드를 재사용 / 코드 재사용, 중복 제거
- 다형성(Polymorphism) : 같은 인터페이스로 다른 동작 수행 / 유연성, 확장성

#### 객체 생성 방법
객체 리터럴
- 가장 간단하고 직관적인 방법. 중괄호 {}로 선언.

객체 속성명 규칙  
1. 카멜 케이스 사용 (예: userName, phoneNumber)
2. 예약어 사용 금지 (예: let, class)
3. 중복된 속성명 사용 금지 → 마지막 값으로 덮어씌워짐
4. 숫자로 시작 금지 (예: 1name)
5. 특수문자 사용 시 따옴표로 감싸기 (예: 'birth-day')

```
// 객체 생성
const obj1 = {};
const obj2 = new Object();
console.log(obj1);
console.log(obj2);

// 객체 생성(속성 선언)
const obj3 = {
    name : '홍길동', // 키 : 값, 키 = 값(에러)
    //age = 20,
    age : 20,
    'birth-day' : '2026-02-25', 
    birthDay : '2026-02-25', 
    1 : '일', // 숫자로 시작하는 속성명은 사용하지 않는다.
    
    // 메소드
    getName : function(){
        return this.name;
    },
    // 메소드 표기법
    setName(name){
        this.name=name;
    },

    // 접근자 프로퍼티
    get info(){
        return `이름: ${this.name}, 나이: ${this.age}, 생년월일: ${this.birthDay}`;
    },
    set setAge(age){
        this.age=age;
    },

    // 중복키 선언 시 마지막 선언된 키와 값으로 엎어쓰여짐
    age : 30,
};
console.log(obj3);
```

#### 객체 속성 접근 방법
1. 점 표기법 (Dot Notation)
- 객체.속성명 형태로 접근. 가장 일반적인 방법.

2. 대괄호 표기법 (Bracket Notation)
- 객체['속성명'] 형태로 접근. 특수문자나 동적 속성명에 사용.

3. 메서드 호출
- 객체.메소드명() 형태로 접근. 특수문자나 동적 속성명에 사용.

```
const obj4 = {
    name : '홍길동',
    age : 20,
    birthDay : '2026-02-25',
    
    // 메소드 선언
    setName : function(name){
        this.name=name;
    },
    getName : function(){
        return this.name;
    },
    set setAge(age){
        this.age=age;
    },
    // 접근자 프로퍼티 (get, set) : 프로퍼티(속성)처럼 코드작성
    get info(){
        return `이름: ${this.name}, 나이: ${this.age}, 생년월일: ${this.birthDay}`;
    },
};
// 속성접근
// 1. 도트 연산자 (ex: 객체참조변수, 속성명)
console.log(obj4.name);
console.log(obj4.info); // 접근자 프로퍼티를 반환 시 속성접근과 동일하게 코드 작성

// 메소드 호출
console.log(obj4.getName());

// 속성접근 수정
obj4.name = '김민수';
console.log(obj4.info);

obj4.setAge=25;
console.log(obj4.info);

obj4.setName('고길동');
console.log(obj4.info);

// 없는 속성을 접근 시 undefined 값 반환
console.log(obj4.email);

// 2. 대괄호 표기법
console.log(obj4['age']);
console.log(obj4['getName']());

// 동적으로 객체 속성을 부여
// 1. 도트 연산자
const obj5 = {};
obj5.name = '홍길동';
obj5.info = function(){
    return this.name;
}

obj5.hobby = ['독서', '음악감상', '영화'];
obj5.car = {
    brand : '테슬라',
    model : '테슬라 S',
};
console.log(obj5);
console.log(obj5.info());
console.log(obj5.hobby[1]);
console.log(obj5['hobby'][1]);
console.log(obj5.car.brand);

// 2. 대괄호 표기법
const key1 = 'id';
const key2 = Symbol(key1);
obj5[key1] = 'ksmartid1';
obj5[key2] = 'ksmartid2';
console.log(obj5);

obj5['getName'] = function(){
    return this.name=name;
}

// Symbol
const sym1 = Symbol('id');
const sym2 = Symbol('id');
console.log(sym1==sym2);
```

#### 객체 관련 연산자
1. in 연산자 - 속성 존재 확인
- '속성명' in 객체 속성 존재 확인시 있으면 true, 없으면 false.

2. delete 연산자 - 속성 삭제
- delete 객체.속성명 속성 있을시 제거.

3. ?. 옵셔널 체이닝 (Optional Chaining)
- 객체?.속성명 속성이 존재하지 않아도 에러 없이 undefined를 반환.

4. ?? 널 병합 연산자 (Nullish Coalescing)
- 객체?.속성명 ?? 기본값 속성이 존재하지 않으면 우항을 반환.

?? vs ||의 차이
- ?? : null과 undefined만 체크
- <pre>|| : 모든 falsy 값 체크 (0, '', false, null, undefined, NaN)</pre>

```
console.log(0 ?? 10);   // 0
console.log(0 || 10);   // 10
console.log('' ?? 'default');   // ''
console.log('' || 'default');   // 'default'
```

```
const obj6 ={
    productName : '모니터',
    productPrice : 1000000,
    productColor : 'black',
    productInfo : {
        address : '전주시 덕진구',
    }
};
// in 연산자
console.log('productName' in obj6); // 속성이 있을 경우 true
console.log('productCode' in obj6); // 속성이 없을 경우 false

// delete 연산자
delete obj6.productColor; // 동적으로 속성삭제
console.log(obj6);

// ?. 옵셔널 체이닝 연산자
console.log(obj6.productInfo?.address);
console.log(obj6.productColor?.detail);

// ?? null 병합 연산자
let obj7;
let obj8 = null;

console.log(obj6 ?? {});
console.log(obj7 ?? {}); // obj7에 빈객체를 할당하는 것이 아니라 obj7이 undefined라면 {}로 반환하겠다.라는 의미
console.log(obj7);
console.log(obj8 ?? {});
console.log(obj8);

// 옵셔널 체이닝 연산자와 널 병합 연산자 활용 예시
console.log(obj6.productColor?.detail ?? '색상없음');
```

#### 객체 순회 - for...in 구문
- 객체의 모든 열거 가능한 속성을 순회.

```
const key3 = Symbol('mobile');
const obj9 = {
    name : '홍길동',
    age : 28,
    [key3] : '010-1234-1234',
    get info(){
        return `이름: ${this.name}, 나이: ${this.age}`;
    },
    getName(){
        return this.name;
    },
};
console.log(obj9);
console.log(obj9[key3]);

// Symbol로 선언한 속성은 제외
for(const key in obj9){
    console.log(key, typeof obj9[key]);
```

#### this 키워드
- this는 메서드를 호출한 객체 자신을 가리킴.
- 메서드 체이닝(Method Chaining)
 : 메서드가 this를 반환하면 연속적으로 메서드를 호출할 수 있음.

```
person1.getThis().getThis().getIdol(2)
```

```
const person1 = {
    idol : ['에스파', '트와이스', '소녀시대', '아이오아이'],
    getThis(){
        console.log('this');
        return this;
    },
    getIdol(idx){
        return this.idol[idx];
    },
    find(groupName){
        for(const element of this.idol){
            if (element === groupName){
                return `있습니다.`;
            } else {
                return `없습니다.`;
            }
        }
    }
};
console.log(person1.getThis().getThis().getThis().getIdol(0));

const ex0Result = person1.find('뉴진스'); // 없습니다.
console.log(ex0Result);
```