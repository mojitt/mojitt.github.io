---
title: 2026.02.06 java 기초(14)
date: 2026-02-06
categories: [국비교육]
tags: [java]
---

#### 제한된 타입 파라미터
- 클래스 또는 인터페이스, 메소드 등에서 타입파라미터의 제한을 하고자 할 때 사용합니다.
- 사용시 제한된 상위 타입의 하위까지만(작성된 타입 포함) 타입파라미터로 전달할 수 있습니다.
		
문법)
- class 클래스면<타입파라미터 extends 제한타입> {}

```
//Grand.class

public class Grand {
	public String grandField1;
	
	public void grandMethod() {
		System.out.println("할머니 메소드");
	}
}
```

```
//Parent.class

public class Parent extends Grand {
	public void method2() {
		System.out.println("엄마 메소드");
	}
}
```

```
//Child1.class

public class Child1 extends Parent {

}
```

```
//Sample2.class

public class Sample <T extends Grand> { //Grand 클래스까지 타입파라미터를 허용 지정
	public T t;
	
	public void method() {
		//if(t instanceof Grand) {
			//Grand g = (Grand)t;
			//g.grandMethod();
		//}
		t.grandMethod();
	}
}
```

```
//Main.class

//현재 Sample 클래스는 자바의 모든 타입을 허용하여 타입파라미터 작성 가능 상태
//Sample<Object> sample1 = new Sample<>(); //Sample 타입파라미터가 Grand 클래스까지 허용하여 불가능
//sample1.t = new Object();
//sample1.method();
		
//Sample<Order> sample2 = new Sample<>(); //Sample 타입파라미터와 관계가 없어 불가능
//sample2.t = new Order();
//sample2.method();
		
Sample<Grand> sample3 = new Sample<>();
sample3.t = new Grand();
sample3.method();
		
Sample<Parent> sample4 = new Sample<>();
Sample<Child1> sample5 = new Sample<>();
Sample<Child2> sample6 = new Sample<>();
//Sample<String> sample7 = new Sample<>();
//Sample<Integer> sample8 = new Sample<>();
```

#### 제한된 타입파라미터를 사용하는 경우
1. 클래스 제한 시
	- 제한 클래스 포함 하위 클래스 까지만 타입파라미터 사용 가능
2. 인터페이스 제한 시
	- 제한된 인터페이스의 구현체만 타입파라미터 사용 가능

```
//SampleSerive.interface

public interface SampleService {
	void sampleMethod1();
}
```

```
//Imple1.class

public class Imple1 implements SampleService {

	@Override
	public void sampleMethod1() {
		System.out.println("Imple1의 구현 메소드");
	}
	
}
```

```
//Imple2.class

public class Imple2 implements SampleService {

	@Override
	public void sampleMethod1() {
		System.out.println("Imple2의 구현 메소드");
	}
	
}
```

```
//Sample4.class

public class Sample4 <T extends SampleService> { //SampleService 인터페이스까지 제한 타입파라미터
	public void sample4Method(T t) {
		//if(t instanceof SampleService) {
			//SampleService s = (SampleService) t;
			//s.sampleMethod1();
		//}
		t.sampleMethod1();
	}
}
```

```
//Main.class

SampleService sampleService = new Imple1();
sampleService.sampleMethod1();
		
sampleService = new Imple2();
sampleService.sampleMethod1();
		
//Sample4<String> sample4_1 = new Sample4<>(); //SampleSerive 인터페이스를 갖고 있는 타입까지만 가능
//sample4_1.sample4Method("A");

//Sample4<Parent> sample4_2 = new Sample4<>(); //SampleSerive 인터페이스를 갖고 있는 타입까지만 가능
//sample4_2.sample4Method(new Parent());
		
Sample4<SampleService> sample4_3 = new Sample4<>();
sample4_3.sample4Method(new Imple1());
sample4_3.sample4Method(new Imple2());
```

#### 외일드 카드란 <?>
- 제네릭을 갖는 클래스 또는 인터페이스를 매개변수 타입으로 두는 경우
- 해당 타입을 지정하지 않고 다양한 타입파라미터를 갖도록 하기 위한 문법입니다.

```
//Order.class

public class Order <T> {
	public T t;
}
```

```
//Grand.class

public class Grand {
	public String grandField1;
	
	public void grandMethod() {
		System.out.println("할머니 메소드");
	}
}
```

```
//Parent.class

public class Parent extends Grand {

}
```

```
//Child1.class

public class Child1 extends Parent {

}
```

```
//Main.class

public static void method2(Order<?> o) {
		
}

public static void method3(Order<? extends Grand> o) { //어떤 타입이 들어와도 되지만 Grand 하위클래스 타입만 가능
	o.t.grandMethod();
}

public static void method4(Order<? super Parent> o) { //어떤 타입이 들어와도 되지만 Grand 상위클래스 타입만 가능
		
}

public static void main(String[] args) {		
//method2에서는 매개변수 타입으로 Order이지만 타입파라미터를 다양하게 전달하고 싶음
method2(new Order<Integer>());
method2(new Order<String>());
method2(new Order<Imple1>());
method2(new Order<Imple2>());
method2(new Order<Parent>());

//method3(new Order<String>()); 타입파라미터로 Grand가 아니므로 불가능
method3(new Order<Child1>()); //Child1은 상위에 Grand가 있으므로 가능
		
method4(new Order<Object>()); //Parent의 상위 Object 이므로 가능
//method4(new Order<Child1>()); Parent의 하위 Child2 이므로
```


## 컬렉션 프레임워크
- 배열과 유사하게 같은 타입의 데이터들을 연속적으로 관리하는 프레임워크 (구조)
		
배열의 문제점)
1. 길이가 고정이다.
2. 중간에 빈 데이터를 유지하고 있으므로 연속 처리시 문제가 발생할 수 있다.

```
String[] strs = {"A", "B", "C", "D"};
		
//strs[4] = "4"; 길이가 고정이므로 존재하지 않는 인덱스에 접근 X
		
strs[1] = null; //배열은 중간 인덱스를 삭제할 수 없으므로 원소 제거시 null 또는 0 값으로 대입해야 합니다.
		
for(int i=0; i<strs.length; i++) {
	//System.out.println(strs[i].equals("A")); 배열 인덱스 중간에 null 값인 원소가 있으므로 예외 발생
}
```

#### List 인터페이스
- 배열과 유사한 구조로 데이터를 관리하는 인터페이스 입니다.
- 구현 클래스) ArrayList(가장 많이 사용), Vector, LinkedList
		
특징)
1. 인덱스로 관리합니다.
2. 중복데이터 허용
3. 원소 추가, 삭제, 수정 용이

```
List<String> list1; //String 타입의 연속된 원소들을 관리하는 List 인터페이스 선언

list1 = new ArrayList<String>(); //구현객체 ArrayList 객체 String 원소타입으로 생성하여 인터페이스에 대입

//원소 추가 (add.() 메소드)
list1.add("A");
list1.add("C");
list1.add("B");
list1.add("D");

//원소 출력 (get.() 메소드)
for(int i=0; i<4; i++) { //list 컬렉션 모든 원소 접근하기
	System.out.println(list1.get(i));
}

//원소 갯수 (size() 메소드)
System.out.println(list1.size()); //4 출력

//특정 인덱스에 추가
//add(인덱스, 원소) -> 해당 인덱스에 원소 추가 / 원래 원소들은 뒤로 한칸씩 밀림 / 바로 뒤 인덱스 추가는 가능 / 건너뛰기는 불가능
//1,2,3,4 -> (0번 인덱스 5 대입) -> 5,1,2,3,4 -> (3번 인덱스 6대입) -> 5,1,2,6,3,4
list1 = new ArrayList<String>();
list1.add("A");

//0번 인덱스에 B 추가
list1.add(0, "B"); //list1 : [B,A]
System.out.println(list1.get(0)); //B 
/*
list1.add(5, "C");
System.out.println(list1.get(5));
System.out.println(list1.get(4));
		
자바에서는 인덱스 순서대로 추가가 가능하며 건너뛰어서 중간 인덱스를 비우고 원소를 추가할 수 없습니다. (자바스크립트는 가능)
*/

//특정 인덱스 원소 변경
//set(인덱스, 원소)
list1.set(0, "C"); //list1 : [C,A]
System.out.println("원소 갯수 : "+list1.size()); //2 
System.out.println("0번 인덱스 : "+list1.get(0)); //C
```