---
title: 2026.02.13 python 기초(2)
date: 2026-02-13
categories: [국비교육]
tags: [python]
---

## 문자열 포매팅

#### format() 정렬하기
- {} 를 숫자와 함께 사용하여 문자열 정렬하기

```
# < 기호 (좌측정렬) : 자릿수 내에서 왼쪽 정렬
print("{0:<15} hi!!" .format("python")) # python          hi!! 출력

# > 기호 (우측정렬) : 자릿수 내에서 오른쪽 정렬
print("{0:>15}" .format("python")) #          python 출력

# ^ 기호 (중앙정렬) : 자릿수 내에서 가운데 정렬
print("{0:^15}" .format("python")) #     python     출력

# 자릿수 내 여백 특정 문자열로 채우기
print("{0:-<16}" .format("python")) # python---------- 출력
```

#### 소수점 표현

```
# %0.4f -> 전체 자릿수 상관 없이 소수점은 4자리 표현
print("{0}" .format(3.1234567))

# 자릿수 상관 없이 소수점 2자리 표현이며 3번째 자리 반올림
print("{0:0.2f}" .format(3.1264567)) # 3.13 출력

# 전체 자릿수 6자리 중 소수점 2자리 표현 정수는 4자리보다 작은 경우 왼쪽 여백
print("{0:6.2f}" .format(3.1264567)) #   3.13 출력
print("{0:6.2f}" .format(123453.1264567)) #123453.13 출력
```

#### {}를 포함하는 문자열 표기

```
print("{{format}}" .format()) # 출력 -> "{format}"
```

#### f 문자열 포매팅
- 접두사 f를 사용하여 문자열을 포매팅하는 방법

```
name = '고길동'
print(f"{name}님 환영합니다.")
print(f"{name+'동'}님 환영합니다.")

age = 30
print(f"올해는 {age}살입니다.")
print(f"내년에는 {age+1}살입니다.")
```


## 문자열 관련 내장 함수

#### 1. count(문자 or 문자열) 함수
- 매개값 문자 또는 문자열이 몇개 있는가 갯수 반환

```
a = 'apple'

print(a.count('p')) # 2
print(a.count('pp')) # 1
print(a.count('pa')) # 0
```

#### 2. index(문자 or 문자엺) 함수
- 매개값 문자 또는 문자열의 시작 인덱스를 반환

```
a = 'banana'

print(a.index('a')) # a들 중 최초 a 인덱스인 1 출력
print(a.index('ba')) # ba는 시작 b가 0번 인덱스이므로 0 출력
# print(a.index('bb')) # 일치하는 문자 또는 문자열이 없다면 오류 발생
```

#### 3. find(문자 or 문자열) 함수
- 매개값 문자 또는 문자열의 시작 인덱스 반환

```
a = 'banana'

print(a.find('a')) # a들 중 최초 a 인덱스인 1 출력
print(a.find('ba')) # ba는 시작 b가 0번 인덱스이므로 0 출력
print(a.find('bb')) # 일치하는 문자 또는 문자열이 없다면 -1 반환
```

#### 4. '문자'.join(문자열) 함수
- 문자열의 문자 사이사이 구분자를 추가한 새로운 문자열 반환

```
a = 'python'
print(','.join(a)) # p,y,t,h,o,n
```

#### 5. 문자열.upper() 함수
- 문자열의 소문자를 대문자로 치환한 새로운 문자열 반환

#### 6. 문자열.lower() 함수
- 문자열의 대문자를 소문자로 치환한 새로운 문자열 반환

#### 7. 문자열.lstrip() 함수
- 왼쪽 공백 제거

```
a = "      python"

print(a) #       python 출력
print(a.lstrip()) # python 출력
```

#### 8. 문자열.rstrip() 함수
- 오른쪽 공백 제거

```
a = "python      "

print(a+"!") # python      ! 출력
print(a.rstrip()+"!") # python! 출력
```

#### 9. 문자열.strip() 함수
- 양쪽 공백 제거

```
a = '     python     '

print("!"+a+"!") # !     python     ! 출력
print("!"+a.strip()+"!") # !python! 출력
```

#### 10. 문자열.replace(대상문자열, 치환문자열) 함수
- 문자열에서 대상문자열을 치환문자열로 치환한 새로운 문자열 반환

```
a = "java"

print(a.replace("j", "J")) # Java 출력
print(a) # java 출력
print(a.replace("a", "A")) # 일치하는 모든 문자열 치환, jAvA 출력
```


## 리스트 자료형
- 연속된 데이터들의 집합 구조를 의미합니다.

```
scores = [80,86,70,89]
scores = [80, 'a', 3.12, 'abc'] # 파이썬에서는 리스트의 모든 원소가 서로 다른 타입일 수 있습니다.

print(scores[1]) # abc 출력
print(scores[3])
#print(scores[5]) # 존재하지 않는 인덱스를 사용하면 오류 발생!

scores[3] = 5
print(scores[3]) # 5 출력

#scores[4] = 'c' # 리스트의 길이 인덱스 접근으로는 변경 할 수 없습니다.
#print(scores[4])
```

#### 리스트 슬라이싱
- 리스트 원소를 잘라 올 수 있습니다.

```
strs = ['a', 'b', 'c', 'd', 'e', 'f']

print(strs[1:3])
print(strs[2:5])

a = [1,2,[1,2,3]] # 정수, 정수, 리스트

print(a[2]) # [1,2,3] 출력
print(a[2][2]) # 3 출력

a = [[1,2],[3,4],[5,6]]

print(a[2][0]) # 5 출력
print(a[-1][0]) # 5 출력
```


## 리스트 연산자

#### 리스트 더하기 (+)
- 서로 다른 리스트를 합친 새로운 리스트를 반환합니다.

```
a = ['a','b','c']
b = [1,2,3]
c = a+b
print(c) # ['a', 'b', 'c', 1, 2, 3] 출력
print(a) # 피연산자 리스트는 변경 x, ['a', 'b', 'c'] 출력
print(b) # 피연산자 리스트는 변경 x, [1, 2, 3] 출력
```

#### 리스트 곱하기 (*)
- 대상 리스트를 횟수만큼 반복한 새로운 리스트를 반환합니다.

```
a = ['a','b','c']
c = a*5
print(c) # ['a', 'b', 'c', 'a', 'b', 'c', 'a', 'b', 'c', 'a', 'b', 'c', 'a', 'b', 'c'] 출력
```

#### len() 함수
- 리스트 원소 갯수

리스트 원소 연산 주의사항
- 원소의 타입과 연산 대상의 타입이 일치하지 않는 경우 오류 발생 할 수 있습니다.- 

```
a = ['a','b','c']
print(len(a)) # 3

#print(b[1]+'a') # 오류
print(type(b[1])) # <class 'int'> 출력
print(type(a)) # <class 'int'> 출력
```

#### 리스트 원소 삭제
- del 키워드를 사용하여 특정 인덱스 원소 삭제가 가능합니다.

```
a = [1,2,3,4,5,6,7,8,9,10]

print(a)
del a[3] # 실제 리스트에서 원소를 삭제합니다.
print(a) # [1, 2, 3, 5, 6, 7, 8, 9, 10] 출력
del a[2:5] 
print(a) # [1, 2, 7, 8, 9, 10] 출력
```


## 리스트 내장 함수

#### 1. 리스트.append(원소)
- 리스트 맨 뒤에 원소를 추가합니다.

```
a = [1,2,3]
print(a)

a.append(4)
print(a) # [1, 2, 3, 4] 출력

# 3개의 원소를 따로 추가하는 것이 아니라 묶어서 리스트 타입으로 하나의 원소를 추가합니다.
a.append([5,6,7]) 
print(a) # [1, 2, 3, 4, [5, 6, 7]] 출력
```

#### 2. 리스트.insert(인덱스, 원소)
- 리스트 인덱스 위치에 원소 추가합니다.

```
a = [1,2,3,4,5,6,7]
print(a)

a.insert(2, 10) # 2번 인덱스에 10 추가 후 나머지 원소들은 뒤로 한칸씩 밀립니다.
print(a) # [1, 2, 10, 3, 4, 5, 6, 7] 출력
```

#### 3. 리스트1.extend(리스트2)
- 리스트1 뒤로 리스트2의 원소들을 각각 확장 합니다.

```
a = [1,2,3]
print(a)

a.extend([4,5,6])
print(a) # [1, 2, 3, 4, 5, 6] 출력
```

#### 4. 리스트.sort()
- 실제 리스트의 인덱스를 원소의 오름차순으로 정렬

```
a = [3,1,7,8,4,100,99]
print(a)

a.sort()
print(a) # [1, 3, 4, 7, 8, 99, 100] 출력

a = ['b', 'a', 'c', 'apple', 'java', 'banana']
print(a)

a.sort() # 사전순 오름차순으로 정렬
print(a) # ['a', 'apple', 'b', 'banana', 'c', 'java'] 출력

#a = [1,6,3,'5',7,4] 
#a.sort() # 리스트에 원소들 타입이 같지 않은 경우 sort() 호출하면 오류 발생
#print(a)

a = [[3,5,2], [1,5,3], [4,6,2]] 
a.sort() # 리스트 원소를 정렬하는 경우 각 첫번째 인덱스 값을 기준으로 정렬
print(a) # [[1, 5, 3], [3, 5, 2], [4, 6, 2]] 출력

a = [5,2,5,3,10,4]
a.sort(reverse=True) # 내림차순 정렬
print(a) # [10, 5, 5, 4, 3, 2] 출력

a = [5,111,2,1,6,3,10,4]
# key -> 정렬 방법을 지정합니다. (abs : 숫자 정렬/절대값 정렬, len : 길이로 정렬/사전순)
a.sort(key=abs) 
print(a) # [1, 2, 3, 4, 5, 6, 10, 111] 출력
```

#### 5. 리스트.reverse()
- 인덱스 역순으로 재정렬합니다.

```
a = [3,2,6,56,8,40,33]
a.reverse()
print(a) # [33, 40, 8, 56, 6, 2, 3] 출력

a.sort() # sort()와 reverse()를 함께 사용하면 내림차순으로 정렬할 수 있습니다.
print(a) # [2, 3, 6, 8, 33, 40, 56] 출력

a.reverse()
print(a) # [56, 40, 33, 8, 6, 3, 2] 출력
```

#### 6. 리스트.remove(원소)
- 리스트에서 일치하는 원소 한개 제거합니다.

```
a = ['a', 'b', 'c', 'a']

a.remove('b')
print(a) # ['a', 'c', 'a'] 출력

a.remove('a') # 'a'가 여러개인 경우 최초 인덱스 한개만 제거합니다.
print(a) # ['c', 'a'] 출력
```

#### 7. 리스트.pop()
- 리스트에서 맨 뒤 인덱스 하나씩 제거

```
a = [1,2,3,4,5,6]
print(a)

a.pop()
a.pop()
print(a) # [1, 2, 3, 4] 출력

# 리스트.pop(인덱스)
# - 리스트에서 해당 인덱스 제거 후 제거 원소값 반환
a = [1,2,3,4,5,6]

value = a.pop(2)
print(value) # 3 출력
print(a) # [1, 2, 4, 5, 6] 출력
```

#### 8. 리스트.count(원소)
- 리스트에서 일치하는 원소의 갯수 반환

```
a = [1,1,1,2,2,2,2]
print(a.count(1)) # 3 출력
```

#### 9. "구분자".join(리스트)
- join 함수를 사용하여 원소를 구분자로 이은 문자열을 반환합니다.
- 원소들이 문자열인 경우만 사용 가능 (파이썬에서는 다른 타입과 문자열을 연결 할 수 없습니다.)

```
a = ['1', '2', '3', '4']
b = '-'.join(a)
print(b) # 1-2-3-4 출력

# 문자열 함수 문자열.split(구분자)
# - 문자열을 구분자로 잘라 리스트르 반환합니다.
a = b.split('-')
print(a) # 1-2-3-4 -> ['1', '2', '3', '4'] 출력
a.append('5')
print(a) # ['1', '2', '3', '4', '5'] 출력
```


## 튜플
- 리스트와 비슷한 데이터 집합 구조입니다.
- 리스트와 다르게 원소 수정, 추가, 삭제가 안됩니다. (변경 불가)
- 리스트보다 처리 속도가 빠릅니다.

#### 튜플 생성하기
- () 괄호를 사용하여 생성합니다.

```
a = (1,2,3)
print(type(a)) # <class 'tuple'> 출력

a = (1)
print(type(a)) # <class 'int'> 출력

# 괄호는 항을 구분할 때도 사용하기 때문에 원소가 하나일때에는 반드시 ,를 붙여 튜플임을 알립니다. 
a = (1,) 
print(type(a)) # <class 'tuple'> 출력

a = 1,2,3 # 튜플 선언시 괄호 생략 가능합니다.
print(type(a)) # <class 'tuple'> 출력

a = 1, # 원소 한개 일 때에도 괄호 생략 가능합니다.
print(type(a)) # <class 'tuple'> 출력
```

#### 인덱스를 활용하여 튜플의 원소값 사용하기

```
a = 1,2,3
print(a[1]) # 2 출력

#a[1] = 10 # 튜플은 값을 수정할 수 없습니다.
#del a[1] # 튜플은 값을 삭제할 수 없습니다.
```

#### 튜플 슬라이싱하기

```
a = 1,2,3,4,5,6,7,8,9,10
b = a[2:6]

print(b) # (3, 4, 5, 6) 출력
#b[1] = 4 # 슬라이싱의 결과도 튜플이므로 원소 수정 x
```

## 튜플에서 사용하는 연산자

#### 1. + 연산자
- 서로 다른 튜플을 합쳐서 새로운 튜플 반환

```
a = 1,2,3
b = 4,5,6
c = a+b

print(c) # (1, 2, 3, 4, 5, 6) 출력
print(a+(4,5)) # (1, 2, 3, 4, 5) 출력
```

#### 2. * 연산자
- 튜플을 횟수만큼 반복한 길이의 튜플을 새로 만들어 반환합니다.

```
c = a*3
print(c) # (1, 2, 3, 1, 2, 3, 1, 2, 3) 출력
```

#### len() 함수
- 튜플의 원소 갯수 알아오기

```
print(len(a)) # 3 출력
```

## 딕셔너리란
- 자바의 map 처럼 키와 값의 쌍으로 데이터를 관리하는 자료형
- 목적 : 키를 알고 있다면 값을 검색 할 수 있도록 합니다.
- 주의 : 키는 중복 될 수 없습니다.

#### 딕셔너리 생성

```
a = {1:10, 2:20, 3:10, 1:20}
print(len(a)) # 중복되는 키 값은 생성 x, 3 출력
```

#### 딕셔너리에서 키로 값을 사용하기

```
# - dic[키] -> 키와 일치하는 값을 반환
print(a[2]) # 20 출력
#print(a[4]) # [] 사용하여 키에 접근하는 경우 일치하는 키가 없으면 오류 발생

# 딕셔너리 선언시 키와 값의 타입은 서로 달라도 생성됩니다.
a = {'a':10, 'b':'20', 3:30}
print(a) # {'a': 10, 'b': '20', 3: 30} 출력

# 리스트 타입은 딕셔너리의 키 타입이 안됩니다. 값으로는 사용 가능
#a = {[1,2]:10}
a = {'a':[1,2]}
print(a) # {'a': [1, 2]}
```

#### 딕셔너리에 키와 값 추가하기

```
a = {
    'name':'홍길동', 
    'age':30, 
    'hobby':['study', 'music', 'movie']
    }

a['address'] = '덕진구'
print(a) # {'name': '홍길동', 'age': 30, 'hobby': ['study', 'music', 'movie'], 'address': '덕진구'} 출력
```

#### 딕셔너리에서 키와 값 삭제하기

```
del a['address']
print(a) # {'name': '홍길동', 'age': 30, 'hobby': ['study', 'music', 'movie']} 출력
```

#### 딕셔너리 키와 일치하는 값 사용하기 (오류 없이)
- 딕셔너리.get(키) -> 키와 일치하는 딕셔너리의 값을 반환 (키가 없어도 오류 x)

```
print(a.get('name')) # 홍길동 출력
print(a.get('address')) # 일치하는 키가 없는 경우 'None' 값 반환, None 출력
print(a.get('address','주소없음')) # 일치하는 키가 없는 경우 '주소없음' 반환, 주소없음 출력
```


## 딕셔너리 내장 함수

#### 1. keys()
- 딕셔너리의 모든 키 목록을 반환 -> 리스트로 변환하여 사용

```
a = {
    'name':'홍길동',
    'age':30,
    'phone':'010-1111-1111',
    'address':'덕진구',
    'hobby':['study','music','movie']
    }

keys = a.keys()
print(keys) # dict_keys(['name', 'age', 'phone', 'address', 'hobby']) 출력

keys = list(keys) # dict_keys 타입을 list로 변환합니다. (추후 반복문을 사용하여 모든 값 접근 가능)
print(keys) # ['name', 'age', 'phone', 'address', 'hobby'] 출력
```

#### 2. values() 함수
- dict_values 타입으로 모든 값의 모음을 반환합니다.

```
values = a.values()
print(values) # dict_values(['홍길동', 30, '010-1111-1111', '덕진구', ['study', 'music', 'movie']]) 출력

values = list(values) # dict_values 타입을 list로 변환합니다.
print(values) # ['홍길동', 30, '010-1111-1111', '덕진구', ['study', 'music', 'movie']] 출력
```

#### 3. items() 함수
- 키와 값의 쌍으로 모든 데이터 목록을 반환합니다. dict_items 타입으로 반환

```
items = a.items()
print(items) # dict_items([('name', '홍길동'), ('age', 30), ('phone', '010-1111-1111'), ('address', '덕진구'), ('hobby', ['study', 'music', 'movie'])]) 출력

items = list(items) # 키와 값은 튜플로 묶어서 리스트 원소로 반환합니다.
print(items) # [('name', '홍길동'), ('age', 30), ('phone', '010-1111-1111'), ('address', '덕진구'), ('hobby', ['study', 'music', 'movie'])] 출력
```

#### 4. clear() 함수
- 전부 제거

```
a.clear()
print(a) # {} 출력
```

### in 연산자
- 리스트, 튜플, 딕셔너리에서 값의 여부를 알 수 있는 연산자입니다.
- 리스트, 튜플 -> 원소 유무
- 딕셔너리 -> 키 유무

문법)
- 비교값 in 리스트|튜플|딕셔너리

```
a = {'a':10, 'b':20, 'c':30, 'd':40}

print('a' in a) # True 출력
print('f' in a) # False 출력

list1 = [1,2,3,4,5]
print(1 in list1) # True 출력
print(10 in list1) # False 출력

tuple1 = 1,2,3
print(1 in tuple1) # True 출력
print(10 in tuple1) # False 출력
```


## set 자료형
- 데이터들의 묶음 구조
- 순서 유지 x, 인덱스 x
- 중복 x

#### set 생성 및 선언
- {} 기호 사용하여 데이터 리터러 선언 시 키:값 의 형태이면 딕셔너리 선언, 값들의 나열이면 set 선언

```
a = set([1,2,3,4,1,2]) # set()를 사용하여 매개값으로 list를 넘기면 중복을 제거한 set 원소들을 만들 수 있습니다.
print(a) # 중복을 허용 x, {1, 2, 3, 4} 출력

a = set("python") # set()를 사용하여 매개값으로 String을 넘기면 한글자씩 원소로 만들어 생성됩니다.
print(a) # {'h', 'y', 'p', 'o', 't', 'n'} 출력

a = {1,2,3,4,1,2} # set 리터럴 {} 표기로 생성하는 방법
print(a) # {1, 2, 3, 4} 출력

# set은 인덱스가 없으므로 인덱스가 필요하면 list 또는 tuple로 변환하여 사용
# set은 특정 원소를 반환 할 수 없으므로 원소값 필요시 list나 tuple로 변환하여 사용
list1 = list(a) # set을 list로 변환
list1.append(1)
print(list1) # 리스트는 중복 허용, [1, 2, 3, 4, 1] 출력

tuple1 = tuple(a) # set을 tuple로 변환
print(tuple1) # (1, 2, 3, 4) 출력
```

#### set에 데이터 추가
- 1개씩 추가 : add(값) 로 추가
- 여러개씩 추가 : update(리스트) 로 추가

```
a.add(5)
a.add(100)
a.add(50) # 숫자형의 경우 대입 순서를 기억하지만 그 외 타입은 순서를 기억하지 않기 때문에 set은 순서에 대하여 배제하고 사용합니다.

print(a) # {1, 2, 3, 4, 5, 100, 50}

a.update([5,6,7,8])
print(a) # {1, 2, 3, 4, 5, 100, 6, 7, 8, 50}
```

#### 서로 다른 set을 사용하여 교집합 구하기
- set1 & set2 -> set1과 set2의 겹치는 원소들 새로운 set으로 반환
- set1.intersection(set2) -> set1과 set2의 겹치는 원소들 새로운 set으로 반환

```
set1 = {1,2,3,4,5}
set2 = {3,4,5,6,7}

result = set1 & set2
print(result) # {3, 4, 5}

result = set1.intersection(set2)
print(result) # {3, 4, 5}
```

#### 서로다른 두 set의 모든 원소의 합집합 set 구하기

```
result = set1 | set2 # 중복은 제거 된 원소들의 합
print(result) # {1, 2, 3, 4, 5, 6, 7}

result = set1.union(set2) # 중복은 제거 된 원소들의 합
print(result) # {1, 2, 3, 4, 5, 6, 7}
```

#### 서로다른 두 set에서 겹치지 않는 원소의 차집합 set 구하기

```
result = set1 - set2 # set1에서 set2에 없는 원소 집합
print(result) # {1, 2}

result = set2 - set1 # set2에서 set1에 없는 원소 집합
print(result) # {6, 7}

result = set2.difference(set1)
print(result) # {6, 7}
```
