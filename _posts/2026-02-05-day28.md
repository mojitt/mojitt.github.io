---
title: 2026.02.05 데이터베이스 기초(8)
date: 2026-02-05
categories: [국비교육]
tags: [database, mysql]
---

#### 프로시저
- 어떠한 동작을 일괄 처리하기 위한 용도
- 자주 사용되는 일반적인 쿼리를 모듈화 시켜 필요할 때만 호출

장점
- 네트워크 트래픽 감소
- 데이터베이스에 비즈니스로직 중앙 집중화
- 데이터 베이스 보안 강화

단점
- 디버깅 어려움
- 유지 보수 복잡성 증가 :  애플리케이션의 설치나 배포가 더 복잡해짐 ( 각 기능을 담당하는 프로그램 코드가 자바와 MySQL 스토어드 프로그램으로 분산되어 관리하기 때문에 )

구문)

```
DELIMITER $$

CREATE PROCEDURE 스토어드 프로시저 이름(IN 또는 OUT 파라미터)
BEGIN
	
	SQL 프로그래밍 코딩…

END $$
DELIMITER ;

CALL 스토어드 프로시저 이름();
```

IN 파라미터 예시)

```
-- 프로시저 초기화
DROP PROCEDURE IF EXISTS sp_member_email;

DELIMITER $$
CREATE PROCEDURE sp_member_email(IN memberId varchar(30), IN memberPw varchar(30))
BEGIN
	SELECT
		m.mbr_email
	FROM
		members m
	WHERE
		m.mbr_id = memberId AND m.mbr_pw = memberPw;
END $$

DELIMITER ;

-- 호출
CALL sp_member_email('ksmartid1', 'ksmartpw1');
```

OUT 파라미터 예시)

```
DROP PROCEDURE IF EXISTS sp_member_addr;

DELIMITER $$
CREATE PROCEDURE sp_member_addr(IN memberId varchar(30), OUT resultAddr varchar(100))
BEGIN 
	SELECT
		concat_ws(' ', m.mbr_addr, m.mbr_daddr) INTO resultAddr
	FROM
		members m
	WHERE
		m.mbr_id = memberId;
END $$

DELIMITER ;

SET @result := '';

CALL sp_member_addr('ksmartid1', @result);

SELECT @result;
```

제어문 if 예시)

```
DROP PROCEDURE IF EXISTS sp_member_grade;

DELIMITER $$
CREATE PROCEDURE sp_member_grade(IN memberId varchar(30))
COMMENT '회원아이디를 입력받아 회원등급을 조회하는 프로시저'
BEGIN 
	-- 선언 키워드는 모조건 최상단에 위치해야한다.
	-- 변수 선언
	DECLARE memberGrade varchar(30);
	-- 변수 값 할당
	SET memberGrade := '';
	-- 변수 선언 및 초기화
	-- DECLARE memberGrade varchar(30) DEFAULT '';
	SELECT 
		m.mbr_grd INTO memberGrade
	FROM
		members m 
	WHERE
		m.mbr_id = memberId;
	
	-- 조건문 IF
	IF (memberGrade = 'mbr_grd_1') THEN 
		SELECT '관리자' AS grade;
	ELSEIF (memberGrade = 'mbr_grd_2') THEN
		SELECT '판매자' AS grade;
	ELSEIF (memberGrade = 'mbr_grd_3') THEN
		SELECT '구매자' AS grade;
	ELSE
		SELECT '회원등급없음' AS grade;
	END IF;
END $$

DELIMITER ;

CALL sp_member_grade('ksmartid2');
```

제어문 case 예시)

```
DROP PROCEDURE IF EXISTS sp_member_grade_case;

DELIMITER $$
CREATE PROCEDURE sp_member_grade_case(IN memberId varchar(30))
COMMENT '회원의 아이디를 입력받아 회원등급을 조회하는 프로시저'
BEGIN 
	-- 변수 선언
	DECLARE memberGrade varchar(20) DEFAULT '';
	DECLARE gradeName varchar(20);
	
	SELECT
		m.mbr_grd INTO memberGrade
	FROM
		members m 
	WHERE
		m.mbr_id = memberId;
	
	-- case 문 
	CASE
		WHEN (memberGrade = 'mbr_grd_1') THEN
			SET gradeName := '관리자';
		WHEN (memberGrade = 'mbr_grd_2') THEN
			SET gradeName := '판매자';
		WHEN (memberGrade = 'mbr_grd_3') THEN
			SET gradeName := '구매자';
		ELSE 
			SET gradeName := '회원등급없음';
	END CASE;
	
	SELECT gradeName AS grade;
END $$

DELIMITER ;

CALL sp_member_grade_case('ksmartid1');
```

제어문 while 예시)

```
-- 일반 while문
DROP PROCEDURE IF EXISTS sp_total_while;

DELIMITER $$
CREATE PROCEDURE sp_total_while(IN endNum int)
COMMENT '0부터 사용자가 입력한 정수 범위의 합계를 구하는 프로시저'
BEGIN 
	-- 카운트 변수
	DECLARE i int DEFAULT 0;
	-- 합계 변수
	DECLARE total int DEFAULT 0;
		
	WHILE (i < endNum) DO
		SET i := i + 1; -- 증감
		SET total := total + i;
	END WHILE;
	
	SELECT total AS '합계';
END $$

DELIMITER ;

CALL sp_total_while(10);

-- iterate(=continue) while문
DROP PROCEDURE IF EXISTS sp_total_while_iterate;

DELIMITER $$
CREATE PROCEDURE sp_total_while_iterate(IN endNum int)
COMMENT '0부터 3을 제외하고 입력한 정수 범위의 합계를 구하는 프로시저'
BEGIN 
	-- 카운트 변수
	DECLARE i int DEFAULT 0;
	-- 합계 변수
	DECLARE total int DEFAULT 0;
		
	while_iterate: WHILE (i < endNum) DO
						SET i := i + 1; -- 증감
						-- java 반복문 continue == iterate
						IF (i = 3) THEN
							ITERATE while_iterate;
						END IF;
						SET total := total + i;
					END WHILE;
	
	SELECT total AS '3을 제외한 합계';
END $$

DELIMITER ;

CALL sp_total_while_iterate(10);

-- leave(=break) while문
DROP PROCEDURE IF EXISTS sp_total_while_leave;

DELIMITER $$
CREATE PROCEDURE sp_total_while_leave(IN endNum int)
COMMENT 'WHILE 종료 제어 연습'
BEGIN 
	-- 카운트 변수
	DECLARE i int DEFAULT 0;
	
	-- java break == leave 레이블
	while_leave: WHILE (i < endNum) do
					SET i := i + 1;
					IF (i = 4) THEN
						LEAVE while_leave;
					END IF;
				END WHILE;
	SELECT i AS '종료 카운트';
END $$

DELIMITER ;

CALL sp_total_while_leave(10);
```

제어문 loop 예시)

```
-- leave(=break) loop문
DROP PROCEDURE IF EXISTS sp_total_loop;

DELIMITER $$
CREATE PROCEDURE sp_total_loop(IN endNum int)
COMMENT '0부터 입력한 정수까지의 범위 합계를 조죄하는 프로시저'
BEGIN 
	-- 카운트 변수
	DECLARE i int DEFAULT 0;
	-- 합계 변수
	DECLARE total int DEFAULT 0;
	
	total_loop: LOOP
					IF (i = endNum) THEN
						LEAVE total_loop;
					END IF;
					SET i := i + 1;
					SET total := total + i;
				END LOOP;
	SELECT total AS '합계';
END $$

DELIMITER ;

CALL sp_total_loop(10);

-- iterate(=continue) loop문
DROP PROCEDURE IF EXISTS sp_total_loop_iterate;

DELIMITER $$
CREATE PROCEDURE sp_total_loop_iterate(IN endNum int)
COMMENT '0부터 3을 제외하고 입력한 정수의 범위 합계를 조회하는 프로시저'
BEGIN 
	DECLARE i int DEFAULT 0;
	DECLARE total int DEFAULT 0;

	total_loop: LOOP
					IF (i = endNum) THEN
						LEAVE total_loop;
					END IF;
					SET i := i + 1;
					IF (i=3) THEN
						ITERATE total_loop;
					END IF;
					SET total := total + i;
				END LOOP;
	SELECT total AS '3을 제외한 합계';
END $$

DELIMITER ;

CALL sp_total_loop_iterate(10);
```

예외처리 예시)

```
DROP PROCEDURE IF EXISTS sp_overflow;

DELIMITER $$
CREATE PROCEDURE sp_overflow()
COMMENT '프로시저 예외처리 실습'
BEGIN 
	DECLARE i int;
	DECLARE total int;
	DECLARE saveTotal int;

	-- 예외처리 핸들러
	-- DECLARE EXIT HANDLER FOR 1264
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
	BEGIN
		-- 예외처리 로직
		SELECT
			 concat('INT 오버플로우 직전의 합계: ', saveTotal) AS '결과1'
			,concat('1+2+3+4+5+...+', i, ' = 오버플로우') AS '결과2';
	END;
	
	SET i := 1;
	SET total := 0;
	
	WHILE (TRUE) DO
		SET saveTotal := total; -- 오버플로우 직접의 합계 할당
		SET total := total + i;
		SET i := i + 1;
	END WHILE;
	
END $$

DELIMITER ;

CALL sp_overflow();
```

#### 커서
프로시저내의 SELECT 문으로 반환된 결과집합을 행 단위로 처리하기 위한 방식

장점
- 행 단위 처리하여 조건에 따라 복잡한 로직 적용 가능

단점
- 행단위로 처리하기 때문에(순차적처리) 병렬 처리 불가 (대용량 일괄처리시 성능저하)
- 프로시저에서만 사용가능. (사용자 정의함수, 트리거에서는 사용불가)

작성시 유의 사항
- 커서를 선언할 시 핸들러 선언보다 앞에 작성해야하고 변수 선언보다는 뒤에 작성해야함.
- 커서 선언에 작성된 결과집합 열의 갯수는 FETCH시의 변수의 갯수와 일치해야함(타입도 일치)

커서 작성구문
- DECLARE done BOOLEAN DEFAULT FALSE;  [커서 종료 변수 선언]
- DECLARE a, b VARCHAR(15); [ 커서 데이터 변수 선언]
- DECLARE cur1 CURSOR FOR SELECT id,data FROM test.t1; [커서 선언 - 결과집합]
- DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE; [커서핸들러선언 – 반환될 행의 없을 때]
- OPEN cur1;  [커서 열기]
- FETCH cur1 INTO a, b; [한 행씩 읽으며 데이터 변수에 할당]
- CLOSE cur1; [커서 닫기]

커서 예시)

```
DROP PROCEDURE IF EXISTS sp_vendor_adjust_price;

DELIMITER $$
CREATE PROCEDURE sp_vendor_adjust_price(IN vendorCd varchar(30), IN ratio DECIMAL(4, 2))
COMMENT '거래처 코드를 입력받아 등록된 상품가격을 조정하는 프로시저'
BEGIN 
	/*
	 DECLARE 선언부 순서
	 1. 변수 선언
	 2. 커서 선언
	 3. 각종 HANDLER 선언
	 */
	DECLARE done boolean DEFAULT FALSE; -- 커서 종료 변수
	DECLARE productCode VARCHAR(20); -- 커서 패치시 사용될 변수(상품코드)
	DECLARE productPrice int; -- 커서 패치시 사용될 변수(상품가격)
	
	-- 커서 선언
	DECLARE productCursor CURSOR FOR
	SELECT 
		prod_cd,
		prod_untprc
	FROM products
	WHERE vend_cd = vendorCd;
	
	-- 커서 패치시 읽을 수 없을 때 실행되는 handler 선언
	DECLARE CONTINUE HANDLER FOR NOT FOUND SET done := TRUE;
	
	-- 커서 열기
	OPEN productcursor;
	
	-- 반복하여 실행한 LOOP 구문작성
	cursor_loop: LOOP
					-- 결과집합 한행씩 읽기
					FETCH productCursor INTO productCode, productPrice;
			
					IF done then	
						LEAVE cursor_loop;
					END IF;
					
					-- 사용자 처리 (비즈니스로직)
					UPDATE products
					SET
						prod_untprc = round(productPrice*ratio, -2)
					WHERE
						prod_cd = productCode;
				END LOOP;
					
	-- 커서 닫기
	CLOSE productcursor;
END $$

DELIMITER ;

CALL sp_vendor_adjust_price('vend_1', 1.1);

SELECT * FROM products WHERE vend_cd  = 'vend_1';
```


#### Function (사용자정의함수)
사용자 정의함수
- 내장함수가 사용자를 만족하는 모든 함수를 제공하지 않아 필요에 의해 사용자가 직접 함수 생성
- 형태와 사용 용도에 프로시저와 차이가 있음

장점
- 애플리케이션 SQL 구문 처리시 일관된 작업을 수행할 수 있음 (모듈성, 효율성)

단점
- 디버깅 어려움
- 유지 보수 복잡성 증가 :  애플리케이션의 설치나 배포가 더 복잡해짐 ( 각 기능을 담당하는 프로그램 코드가 자바와 MySQL 스토어드 프로그램으로 분산되어 관리하기 때문에)

사용자 정의함수 특징
- 파라미터 in, out을 사용할 수 없다.
	- 함수의 파라미터는 모두 입력 파라미터로 사용된다.
- 리턴 값이 있다.
	- 프로시저는 반환하는 구문이 없지만 함수는 반드시 하나의 값을 반환해야한다.
- 호출이 다르다.
	- 프로시저는 CALL 명령어로 호출하지만 함수는 DML문장 안에서 호출된다.
- 집합결과를 반환하는 SELECT문은 사용할 수 없다.
	- 단일 값을 반환하는 SELECT문은 사용가능.
	- 하나의 값만 반환하기 때문에 집합의 결과 값은 반환할 수 없다.

구문)

```
-- 사용자 정의 함수 생성권한 확인
SHOW variables LIKE '%log_bin_trust_function_creators%';

-- 값이 OFF라면 ON으로 변경해야함
SET GLOBAL log_bin_trust_function_creators = 1;

DROP FUNCTION IF EXISTS 함수명;

-- 사용자 정의함수 선언
DELIMITER $$
CREATE FUNCTION 함수명(매개변수명 데이터타입)
RETURNS 반환데이터타입
COMMENT ''
BEGIN 
	RETURN 값;
END $$

DELIMITER ;
```

예시)

```
DROP FUNCTION IF EXISTS sf_sum;

-- 사용자 정의함수 선언
DELIMITER $$
CREATE FUNCTION sf_sum(intValue1 int, intValue2 int)
RETURNS int
COMMENT '두 정수의 합계를 반환하는 함수'
BEGIN 
	DECLARE total int DEFAULT 0;
	SET total := intValue1 + intValue2;

	RETURN total;
END $$

DELIMITER ;

SELECT sf_sum(10, 20);
```
