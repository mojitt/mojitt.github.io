---
title: 2026.01.27 java 기초(9)
date: 2026-01-27
categories: [국비교육]
tags: [java]
---

## 타입변환과 다형성
#### 다형성
같은 타입이지만 실행 결과가 다양한 객체 대입(이용) 가능한 성질
- 부모 타입에는 모든 자식 객체가 대입 가능
	- 자식 타입은 부모 타입으로 자동 타입 변환
- 효과 : 객체 부품화 가능

```
//Parent1.class

public class Parent1 extends Grand {

	public void method1() {
		System.out.println("Parent1의 method1 호출");
	}
	
	@Override
	public void method0() {
		System.out.println("Parent1에서 재정의한 method0 호출");
	}
	
}
```

```
//Parent2.class

public class Parent2 extends Grand {

	public void method001() {
		System.out.println("Parent2의 method001 호출!");
	}
	
	@Override
	public void method0() {
		System.out.println("Parent2에서 재정의한 method0 호출");
	}
}
```

```
//Grand.class

public class Grand {
	
	public void method0() {
		System.out.println("Grand1의 method0 호출");
	}
	
}
```

```
//Main.class

/*
 상속에서의 다형성
 원리 : 부모 타입 변수에는 자식객체가 자동형변환된다.

 1.필드의 다형성
 부모 타입을 필드로 뒀을 때 어떤 자식 객체가 대입되는냐에 따라
 자식의 오버라이딩 된 부모 메소드 호출 결과가 달라지므로
 같은 실행문이지만 다른 결과를 반환 또는 실행합니다.

 2.매개변수의 다형성
 부모 타입을 메소드의 매개변수로 뒀을 때 어떤 자식 객체가 매개값이 되는냐에 따라
 같은 메소드 호출이지만 실행결과가 달라지는 것을 의미합니다.
 */

Parent1 parent1 = new Parent1();
Parent2 parent2 = new Parent2();
		
parent1.method0();  //"Parent1에서 재정의한 method0 호출"
parent2.method0();  //"Parent2에서 재정의한 method0 호출"
		
Grand grand = parent1;
grand.method0();  //"Parent1에서 재정의한 method0 호출"
	
grand = parent2;
grand.method0();  //"Parent2에서 재정의한 method0 호출"
```

#### 자동 타입 변환
상속에서의 자동형변환  
원리 : 자식객체는 반드시 부모객체를 가지고 있다.
- 자식 객체를 부모타입 클래스 변수에 대입하는 것을 의미한다.
- 자동형변환 시 멤버 사용범위 : 부모의 멤버까지만 사용 가능

```
//Child1.class

public class Child1 extends Parent1 {
	
	public void method2() {
		System.out.println("Child1의 method2 호출");
	}
	
	@Override
	public void method1() {
		System.out.println("Child1에서 method1 재정의하여 호출");
	}
}
```

```
//Parent1.class

public class Parent1 {

	public void method1() {
		System.out.println("Parent1의 method1 호출");
	}
	
	
}
```

```
//Main.class

Child1 child1 = new Child1();
child1.method1();  //"Child1에서 method1 재정의하여 호출"
		
Parent1 parent1 = new Parent1();
parent1.method1();  //"Parent1의 method1 호출"
		
parent1 = child1; //자동형변환
parent1.method1();  //"Child1에서 method1 재정의하여 호출"
```

#### 강제타입변환
- 원리 : 부모 타입 변수 안에 어떤 자식이 담겨있을지 모르기 때문
- 부모타입변수의 객체를 자식 타입변수에 대입하는 것을 의미합니다.

```
//Main.class
//Parent1과 Child1은 상속관계

Parent1 parent1 = Parent1();
Child1 copyChild1;
/*
 컴파일러는 변수 내부의 데이터 검증은 하지 않으므로
 부모는 여러 자식 클래스를 둘수 있어 어떤 자식 객체일지 확신할 수 없다.
 그래서 컴파일 오류가 발생한다.
 copyChild1 = parent1;
 */
copyChild1 = (Child1) parent1;  //강제형변환
```


## 추상 클래스
추상 클래스
- 실체 클래스들의 공통되는 필드와 메소드 정의한 클래스
- 추상 클래스는 실체 클래스의 부모 클래스 역할 (단독 객체x)

#### 추상 클래스의 용도
- 실체 클래스의 공통된 필드와 메소드의 이름 통일할 목적
	- 실체 클래스를 설계자가 여러 사람일 경우,
	- 실체 클래스마다 필드와 메소드가 제각기 다른 이름을 가질 수 있음
- 실체 클래스를 작성할 때 시간 절약
	- 실체 클래스는 추가적인 필드와 메소드만 선언
- 실체 클래스 설계 규격을 만들고자 할 때
	- 실체 클래스가 가져야 할 필드와 메소드를 추상 클래스에 미리 정의
	- 실체 클래스는 추상 클래스를 무조건 상속 받아 작성

#### 추상 클래스 선언
클래스 선언에 abstract 키워드 사용
- New 연산자로 객체 생성하지 못하고 상속 통해 자식 클래스만 생성 가능
- public abstract class 클래스명 {...}

```
//Animal.class

public abstract class Animal {

	/*
	 추상 클래스
	 추상 : 실체 간의 공통되는 속성 또는 기능을 추출한 것을 의미합니다.
	 현실의 개념을 실제 java로 옮겨 실체 객체가 될 수 없는 실체 객체의 공통 속성, 
	 기능을 추출한 추상 클래스를 정의할 수 있습니다.
	 abstract 키워드를 사용하여 정의할 수 있습니다.
	 */

	public int legCnt;
	public String name;
	public String kind;	
}
```

```
//Cat.class

public class Cat extends Animal{

}
```

```
//Main.class

//Animal 클래스 : 추상클래스
//Animal animal = new Animal(); 추상 클래스는 new 생성자(); 호출을 할 수 없어 객체를 만들 수 없습니다.
		
Cat cat = new Cat();
cat.legCnt = 4;
cat.name = "고양이";
cat.kind = "고양이과";
System.out.println(cat.legCnt);  //4
System.out.println(cat.name);  //고양이
System.out.println(cat.kind);  //고양이과
```


#### 추상 메소드 선언
메소드 이름 동일하지만, 실행 내용이 실체 클래스마다 다른 메소드 

구현방법
- 추상 클래스에는 메소드의 선언부만 작성 (추상 메소드)
- 실체 클래스에서 메소드의 실행 내용 작성(오버라이딩(Overriding))

```
//Animal.class

public abstract class Animal {

	/*
	 추상 메소드란,
	 추상 클래스에서 실행 블럭이 없는 추상의 메소드를 의미합니다.
	 문법) 접근제한자 abstract 리턴타입 메소드명([매개변수, ...]);
		 
	 목적 : 하위 클래스에서 모두 부모의 메소드를 재정의하여 사용하는 경우 
	 메소드 선언시 메소드명 정형화 하기 위하여 사용합니다.
	 */

	public abstract void sound(); //추상메소드 -> 반드시 하위 클래스에서 정의해야합니다.
}
```

```
//Cat.class

public class Cat extends Animal{
	@Override
	public void sound() {
		System.out.println("야옹 웁니다.(추상메소드 정의)");
	}
}
```


## 인터페이스
개발 코드와 객체가 서로 통신하는 접점

#### 인터페이스 역할
개발 코드가 객체에 종속되지 않게 -> 객체 교체할 수 있도록 하는 역할  
개발 코드 변경 없이 리턴값 또는 실행 내용이 다양해 질 수 있음 (다형성)

#### 인터페이스 선언
- 인터페이스 이름 - 자바 식별자 작성 규칙에 따라 작성
- 소스 파일 생성
	- 인터페이스 이름과 대소문자가 동일한 소스 파일 생성
- 인터페이스 선언
	- [public] interface 인터페이스명 {...}

```
//BoardService.interface

public interface BoardService {
	Board[] list(); //[public abstract] void list(); 인턴페이스에서 default 접근제한자는 사용할 수 x
}
```

```
//NoticeBoard.class

public class NoticeBoard extends Board implements BoardService {

	public boolean isNotice;

	@Override
	public Board[] list() {
		
		Board[] boards = new Board[2];
		
		NoticeBoard nb1 = new NoticeBoard();
		nb1.setTitle("공지사항1");
		nb1.setBno(1);
		nb1.isNotice = true;
		
		NoticeBoard nb2 = new NoticeBoard();
		nb2.setTitle("공지사항2");
		nb2.setBno(2);
		nb2.isNotice = true;
		
		boards[0] = nb1;
		boards[1] = nb2;
		
		
		return boards;
	}
}
```

```
//Board.class

public class NoticeBoard extends Board implements BoardService {

	public boolean isNotice;

	@Override
	public Board[] list() {
		
		Board[] boards = new Board[2];
		
		NoticeBoard nb1 = new NoticeBoard();
		nb1.setTitle("공지사항1");
		nb1.setBno(1);
		nb1.isNotice = true;
		
		NoticeBoard nb2 = new NoticeBoard();
		nb2.setTitle("공지사항2");
		nb2.setBno(2);
		nb2.isNotice = true;
		
		boards[0] = nb1;
		boards[1] = nb2;
		
		
		return boards;
	}
}
```

```
//Board.class

public class Board {
	private int bno;
	private String title;
	private String content;
	private String id;
	private String wdate;
	private int hit;
	
	public int getBno() {
		return bno;
	}
	
	public void setBno(int bno) {
		this.bno = bno;
	}
	... //나머지 getter, setter
}
```

```
//Main.class

//BoardService boardService = new BoardService(); 인터페이스는 객체화 할 수 없습니다.
	
BoardService boardService;  //인터페이스 변수 선언 (통행로)
		
boardService = new NoticeBoard();  //인터페이스에 구현 객체 대입, (통행로를 지나면 NoticeBoard가 반겨준다.)
		
Board[] boards = boardService.list();  //NoticeBoard 객체의 list 메소드 호출
		
for(Board board : boards) {
	NoticeBoard nBoard = (NoticeBoard) board;  //isNotice 필드는 부모인 Board 클래스에는 없기 때문에 강제형변환
	System.out.println("--------------");
	System.out.println(nBoard.getTitle());
	System.out.println(nBoard.getBno());
	System.out.println(nBoard.isNotice);
	System.out.println("--------------");
}
```