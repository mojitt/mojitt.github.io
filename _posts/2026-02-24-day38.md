---
title: 2026.02.24 javascript 기초(3)
date: 2026-02-24
categories: [국비교육]
tags: [javascript]
---

#### 레이블 문 (Label)
- label: { ... } 처럼 블록/반복문/switch에 이름을 붙이는 문법
- break label; 로 바깥(레이블이 붙은) 블록까지 탈출 가능
- 주의: 흐름이 복잡해져 가독성이 떨어질 수 있어 남용 금지

```
/*
블록문은 switch, 레이블구문을 제외하고는 break 사용할 수 없다.
if(true){
    break;
}
*/

block : {
        break block;
        console.log('블록 코드 실행');
}

outerFor : for(let j=0; j < 3; j+=1){
                for(let k=0; k < 3; k+=1){
                    if(k==1)break outerFor; // 레이블을 선언한 블록에서 빠져나온다.
                    console.log(`break j: ${j}, k: ${k}`); 
                }
            }
```


## 배열
- 배열(Array)은 하나의 저장소를 인덱스(index)로 분할해 데이터를 저장하는 객체
- index는 0부터 시작
- 배열에 담긴 각 값은 요소(원소, element)라고 부름
- JS는 타입이 고정되지 않아 다양한 타입의 요소를 담을 수 있음

```
// 배열 선언
const arr1 = new Array(); // 생성자 함수 선언
const arr2 = []; // 리터럴 선언 (권장)
console.log(arr1);
console.log(arr2);

// 배열 생성 및 요소 초기화
const arr3 = new Array(2); // 인수가 number 타입인 경우 인수의 길이를 가진 빈배열생성
const arr4 = [2];
const arr5 = new Array(2,3,4);
console.log(arr3); 
console.log(arr4);
console.log(arr5);

// JS 배열 : 타입이 정해져있지 않기 때문에 모든 데이터타입을 담을 수 있다.
const arr6 = [1, '일', true, null, undefined, [], {}, function(){}];
console.log(arr6);
```

#### 배열에 값 대입 및 접근
- 배열[index] 로 요소에 접근 가능
- 배열[index] = 값 으로 요소 재할당 가능
- 배열 length를 이용해 "맨 뒤에" 안전하게 추가 가능

length는 “읽기 전용”이 아니라 조작 가능
- length를 줄이면 뒤 요소가 삭제됨(실무 주의)
- length를 늘리면 빈 슬롯이 생김

```
// 배열 index(요소의 주소) 0부터 시작
const nums1 = [100,200,300,400];
console.log(nums1[0]);
console.log(nums1[4]); // 요소의 인덱스가 존재하지 않으면 undefined를 반환

// 배열의 크기(length)
const nums2 = [100,200,300,400];
console.log(nums2.length);

// 주의! 배열의 요소 값 직접 접근 할당 (권장하지 않음)
const nums3 = [100,200,300,400];
nums3[0] = 0;
console.log(nums3);
nums3[1000] = 1000;
nums3[nums3.length] = 1001;
nums3.length = 200; // 배열의 크기를 임의 변경하면 안된다. (배열의 요소를 유실할 수 있음)
console.log(nums3);
```

#### 배열 객체의 속성 및 메서드
- length : 배열의 크기를 알 수 있는 속성
- push/pop, unshift/shift, splice, Array.isArray 등 (기본 조작)

- 배열/객체/null 모두 typeof가 object로 나올 수 있으므로 배열 판별은 Array.isArray 권장

끝(Last) 요소 조작
- push() : 배열 마지막에 요소를 추가하고, 변경된 length를 반환 / arr.push(10) → length 반환
- pop() : 배열 마지막 요소를 제거하고, 제거된 요소를 반환 / arr.pop() → 제거된 값 반환

앞(First) 요소 조작
- unshift() : 배열 처음에 요소를 추가하고, 변경된 length를 반환 / arr.unshift(10) → length 반환
- shift() : 배열 처음 요소를 제거하고, 제거된 요소를 반환 / arr.shift() → 제거된 값 반환

중간 요소 조작
- splice() : 지정한 index부터 요소를 삭제/추가할 수 있으며, 삭제된 요소들을 배열로 반환 / arr.splice(2, 1) → 삭제된 요소 배열 반환 arr.splice(2, 0, 99) → 2번 위치에 99 삽입

판별 (검사)
- Array.isArray() : 전달한 값이 배열이면 true, 아니면 false 반환 / Array.isArray([]) → true Array.isArray({}) → false

```
console.log('========배열 메소드========');
        
const nums4 = [10,20,30,40];
let returnRs;

// push : 배열 마지막 요소 추가
returnRs = nums4.push(50)
returnRs = nums4.push(60,70,80)
console.log(nums4);
console.log(returnRs, '<-- 변경된 배열의 크기');

// pop : 배열 마지막 요소 제거
returnRs = nums4.pop();
console.log(nums4);
console.log(returnRs, '<-- 제거된 요소');

// unshift : 배열 처음 요소 추가
returnRs = nums4.unshift(-20,-10,0);
console.log(nums4);
console.log(returnRs, '<-- 변경된 배열의 크기');

// shift : 배열 처음 요소 제거
returnRs = nums4.shift();
console.log(nums4);
console.log(returnRs, '<-- 제거된 요소');

// splice : 배열 특정요소를 제거
// splice(시작할 인덱스, 제거할 요소 갯수)
returnRs = nums4.splice(1,1);
console.log(nums4);
console.log(returnRs, '<-- 제거된 요소(자료형: 배열)');
returnRs = nums4.splice(0,3);
console.log(nums4);
console.log(returnRs, '<-- 제거된 요소(자료형: 배열)');

// splice(시작할 인덱스, 제거할 요소 갯수, ...추가할 요소)
returnRs = nums4.splice(0,0,10,20);
console.log(nums4);
console.log(returnRs, '<-- 제거된 요소(자료형: 배열)');

// 생성된 배열의 초기화 (빈배열) : 요소 전체 삭제
// splice(시작할 인덱스) : 시작할 인덱스부터 요소 전체삭제
returnRs = nums4.splice(0);
console.log(nums4);
console.log(returnRs, '<-- 제거된 요소(자료형: 배열)');

//nums4.splice(0,0,...returnRs);
nums4.push(...returnRs);
console.log(nums4);

// Array.isArray(리터럴) : 배열여부 판단(true | false)
let obj;
obj = [];
if(Array.isArray(obj)) obj.push(100);
console.log(obj);

obj = 0;
if(Array.isArray(obj)) obj.push(100);
console.log(obj);
```

## 배열과 반복문
#### for (index 기반 순회)
- 배열은 index(0부터)로 접근 가능: arr[i]
- 원본 배열을 수정해야 할 때 index 기반 for가 직관적
- 반복 조건은 보통 i < arr.length 형태

```
const nums5 = [10,20,30,40];
for(let idx=0; idx < nums5.length; idx++){
    //console.log(nums5[idx]);
    nums5[idx] *= 10;
}
console.log(nums5);
```

#### for..of (값(value) 순회)
- for..of는 이터러블(iterable)을 순회하는 문법
- 배열의 요소(값)가 매 반복마다 변수에 할당됨
- 숫자/문자열 같은 원시값은 복사되어 들어오므로, 변수만 바꿔도 원본 배열은 안 바뀜

- 주의 1) element /= 10 같은 코드는 element 변수만 바뀌고 배열은 그대로임(원시값일 때)
- 주의 2) 배열 요소가 객체라면 element.name = ... 같은 내부 변경은 원본에도 반영됨(참조값)

```
const nums6 = [10,20,30,40];
for(let element of nums6){
    // 배열의 요소를 복사하여 할당하기 때문에 배열의 변경은 없다.
    element*=10; 
    console.log(element);
}
console.log(nums6);
```

#### 객체 순회: for..in
- for..in은 객체의 키(key)를 순회하는 문법
- 객체 값 접근은 obj[key] 방식(대괄호 표기법) 사용

- 주의) for..in은 객체의 상속된 열거 가능 속성까지 포함될 수 있음
- 배열 순회 시에는 for of

```
// for in 구문으로 배열요소 순회는 가능하나 권장하지 않음.
const nums7 = [10,20,30,40];
for(const key in nums7){
    console.log(typeof key, nums7[key]);
}
```

#### 얕은복사 vs 깊은복사
- 얕은복사: "참조값(주소)"을 복사 → 같은 객체/배열을 함께 바라봄(원본 영향 가능)
- 깊은복사: "값"을 새 메모리에 복제 → 서로 다른 객체/배열(원본 영향 없음)

- 주의: 중첩 배열/객체가 포함되면, 1단계 복사는 내부 참조를 공유할 수 있음
- 즉, 겉만 새로 만든다고 해서 “완전한 깊은복사”가 되는 건 아님

```
// 값 복제 (기본 데이터 타입)
let num1 = 100;
let num2 = num1;

num2 = 200;
console.log(num1, num2);

// 객체 참조값 복제
const copyTargetArr = [100,200,300,400];
const shallowCopyArr = copyTargetArr;

const deepCopyArr = [];
for(const element of copyTargetArr){
    deepCopyArr.push(element);
}

shallowCopyArr[0] = 0; // 원본배열과 같은 조소를 참조
deepCopyArr[1] = 1; // 새로운 배열을 참조하기 때문에 원보배열을 훼손하지 않는다.

console.log(copyTargetArr);
console.log(shallowCopyArr);
console.log(copyTargetArr == shallowCopyArr); // 얖은 복사 후 배열비교 : true
console.log(deepCopyArr);
console.log(copyTargetArr == deepCopyArr); // 깊은 복사 후 배열비교 : false
```