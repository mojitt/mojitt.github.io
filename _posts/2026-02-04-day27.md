---
title: 2026.02.04 데이터베이스 기초(7)
date: 2026-02-04
categories: [국비교육]
tags: [database, mysql]
---

## UNION
- 여러 개의 쿼리의 합집합
- 여러 개의 SQL문을 합쳐 쿼리의 결과를 행으로 합치는 것

#### UNION vs UNION ALL
- UNION : 여러 개의 쿼리의 중복 값을 제거한 결과
- UNION ALL : 여러 개의 쿼리 결과가 중복이 되더라도 전부 결과에 반영
- 속도 : UNION ALL > UNION

#### UNION 사용 규칙
- 각 SELECT의 컬럼의 수가 같아야 한다.
- 컬럼명이 같아야 한다. (같지 않을 경우 alias를 사용하여 같게 만듦)
- 컬럼별 데이터타입이 같아야한다.
- 하나의 ORDER BY만 사용
- SELECT 문(SQL문)의 순서는 상관없다.

#### UNION

```
SELECT
	 m.mbr_id AS memberId
	,m.mbr_reg_date
FROM
	members m
UNION
SELECT
	 mll.login_id AS memberId
	,mll.login_date 
FROM 
	members_login_log mll ;

-- 열 갯수 같음
```

#### UNION ALL

```
SELECT
	 m.mbr_email AS memberEmail
	,m.mbr_telno 
	,m.mbr_reg_date 
FROM
	members m
UNION ALL
SELECT 
	 v.vend_addr AS memberEmail
	,v.vend_telno 
	,p.prod_untprc 
FROM
	vendors v INNER JOIN products p 
	ON v.vend_cd = p.vend_cd 
ORDER BY memberEmail desc;

-- 열 갯수 맞춤
-- order by 하나만 사용
```

#### COALESCE
COALESCE(인수1, 인수2, 인수3....) : 인수1의 값이 NULL 일 경우는 인수2 반환

```
SELECT COALESCE(NULL, NULL, '영'); -- '영' 반환
```

#### mysql full outer join 
- mysql full outer join 지원안함 -> union을 활용해서 구현
- left join 결과와 right join 결과를 union all 활용

```
SELECT
	*
FROM 
	budget_plan bp LEFT JOIN actual_sales t -- left join 사용
	ON bp.department = t.department AND (bp.`year`, bp.`month`) = (t.`year`, t.`month`)
	LEFT JOIN departments d 
	ON d.department_id = COALESCE(bp.department, t.department)
UNION  -- left join와 right join을 UNION 하여 모든 값 갖고옴
SELECT
	*
FROM 
	budget_plan bp RIGHT JOIN actual_sales t  -- right join 사용
	ON bp.department = t.department AND (bp.`year`, bp.`month`) = (t.`year`, t.`month`)
	LEFT JOIN departments d 
	ON d.department_id = COALESCE(bp.department, t.department) ;
```

## CTE (Common Table Expression)
- 단일 명령문의 범위 내에 존재하는 명명된 임시 결과 집합
- 해당 명령문 내에서 여러 번 참조 될 수 있으며 간결한 식으로 보여지는 장점
- MySQL 8.0 이후에서만 지원

```
-- 문법
WITH CTE_테이블이름
AS
(
   SELECT
      *
   FROM
      table1 t1  LEFT JOIN  table2 t2
      ON t1.key = t2.key
)
SELECT * FROM CTE_테이블이름;

-- 예시
WITH grade AS
(SELECT
	 cgc.comm_group_cd
	,cgc.comm_group_nm 
	,cc.comm_cd 
	,cc.comm_nm 
FROM
	comm_group_code cgc INNER JOIN comm_code cc 
	USING (comm_group_cd)
WHERE
	cgc.comm_group_cd = 'comm_group_1'), -- CTE를 여러개 사용할 경우 ',' 를 사용
mbr AS 
(SELECT
	 m.mbr_id 
	,m.mbr_name 
	,m.mbr_email 
	,m.mbr_grd 
	,g.comm_nm nm
FROM 
	members m INNER JOIN grade g
	ON m.mbr_grd = g.comm_cd)
SELECT * FROM mbr;
```

## VIEW (가상테이블)
- 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가지는 가상 테이블
- 물리테이블로 유도된 논리테이블 (논리적 독립성) => 삽입, 수정, 삭제 제약이 있다.

#### VIEW 특징
- 기본테이블로부터 유도된 테이블이기에 테이블과 같은 형태의 구조이며 조작도 테이블과 거의 같음
- 가상테이블이기에 데이터의 논리적 독립성을 제공
- 뷰를 통해서만 데이터블 접근하여 뷰에 나타나지 않는 데이터 보안에 도움.
- 필요한 데이터만 뷰로 정의해서 처리하기에 관리에 용이하고 명령문이 간단함

#### VIEW 단점
- 복잡한 뷰일 경우 테이블의 조인 연산등으로 실시간 데이터를 가져오므로 성능 저하가 일어남. 
- 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신 연산에 제약이 따름.

#### MySQL 뷰(VIEW)의 제약사항
- 뷰의 정의는 SELECT 구문이 허용하는 WHERE, GROUP BY 와 같은 것을 모두 포함 가능.
- 뷰와 함께 연결되는 트리거를 만들 수 없다.
- 뷰 정의에 있는 SELECT 구문은 다음과 같은 구성을 포함할 수 없다.
	- FROM 절 안에 서브쿼리
	- 임시테이블로 참조 (세션과 관련: 연결이 종료되면 사라짐)
	- 사용자 변수로 참조 (세션과 관련: 연결이 종료되면 사라짐)

#### MySQL 뷰(VIEW)의 생성 및 삭제 구문
- 생성 : CREATE VIEW 뷰이름 AS SQL구문 ;
- 삭제 : DROP VIEW 뷰이름 ;

```
-- 예시

-- VIEW 생성
CREATE VIEW v_dormant_members AS
SELECT
	 m.mbr_id 
	,m.mbr_name 
	,m.mbr_email 
FROM
	members m LEFT JOIN members_login_log mll 
	ON m.mbr_id = mll.login_id 0

WHERE
	mll.login_no IS NULL;

-- VIEW 확인
SELECT * FROM v_dormant_members;

-- VIEW 삭제
DROP VIEW v_dormant_members;
```

## Stored Program
- 일련의 쿼리를 마치 하나의 함수처럼 실행하기 위한 쿼리의 집합
- MySQL 안에서 프로그래밍 언어와 같은 기능을 제공하는 프로그램
- 자주 사용하는 복잡한 쿼리를 하나로 묶어서 이름으로 지정하여 이름을 호출하여 실행하도록 설정

#### Stored Program 장점
- 긴 쿼리의 내용을 전송하지 않고 프로시저의 이름 및 매개변수 등만 전송하여 네트워크 부하를 줄일 수 있음 ( 성능 향상 )
- 직접 SQL문을 작성하지 않고 저장된 이름만 호출함으로써 일관된 작업을 함 ( 유지관리 간편 ) 
- 한 번 Stored Program을 생성해 쿼리의 수정, 삭제 등의 관리가 수월 (모듈식 프로그래밍 가능)
- 사용자 별로 테이블에 접근 권한을 주지 않고 Stored Program에 접근 권한을 줌으로써 보안 강화

#### Stored Program 종류
프로시저
- 쿼리문의 집합으로 어떠한 동작을 일괄 처리하기 위한 용도로 사용

함수
- 사용자 정의 함수 (내장함수가 제공하지 않아 시스템에 유용한 함수 정의)

트리거
- 테이블의 DML동작이 일어나면 실행되는 프로그램 (방아쇠)

커서
- 테이블에서 여러 개의 행을 쿼리한 후에, 쿼리의 결과인 행 집합을 한 행씩 처리하는 방식