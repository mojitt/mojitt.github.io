---
title: 2026.01.28 java 기초(10)
date: 2026-01-28
categories: [국비교육]
tags: [java]
---

#### 상수 필드 선언
인터페이스는  상수 필드만 선언 가능
- 데이터 저장하지 않음  

인터페이스에 선언된 필드는 모두 public static final
- 자동적으로 컴파일 과정에서 붙음  

상수명은 대문자로 작성
- 서로 다른 단어로 구성되어 있을 경우에는 언더 바(_)로 연결  

선언과 동시에 초기값 지정
- static { } 블록 작성 불가   
- static { } 으로 초기화 불가

```
//BoardService.interface

public interface BoardService {

	//인터페이스는 인스턴스 필드와 정적 필드는 가질 수 없으며 상수만 가질 수 있습니다.
	public static final int MIN_HIT = 0; //[public static final] 생략 가능
	
	/*
	 인터페이스 상수를 선언하는 이유
	 - 모든 구현 클래스에서 공통으로 사용하는 상수의 경우 인터페이스에 두고 사용할 수 있습니다.
	 - 메모리를 효율적으로 관리 할 수 있습니다.
	 - 공통 상수의 이름을 규격화 할 수 있습니다.(이름 통일)	 
	 */
	
	void write(String title, String content, int hit);
}
```

```
//QnAService.class

public class QnAService implements BoardService {

	@Override
	public void write(String title, String content, int hit) {
		System.out.println("문의 게시글 등록 입니다.");
		System.out.println("------------------");
		System.out.println("제목 : "+title);
		System.out.println("내용 : "+content);
		
		if(hit > BoardService.MIN_HIT) { //BoardService.MIN_HIT -> 인터페이스 상수 사용
			System.out.println("조회수 : "+hit);
		} else {
			System.out.println("조회수 값 오류");
		}
		
		System.out.println("------------------");
	}
}
```

#### default 메소드 선언
- 자바8에서 추가된인터페이스 새로운 멤버
- 문법) [public] default 리턴타입 메소드명(매개변수, ...) {...}
- 실행 블록을 가지고 있는 메소드
- default 키워드를 반드시 붙여야
- 기본적으로 public 접근 제한 (생략하더라도 컴파일 과정에서 자동으로 붙음)

```
//BoardService.interface

public interface BoardService {

	/*
	 디폴트 메소드란,
	 모든 구현 객체가 갖는 공통 기능을 인터페이스 쪽에 정의하는 것을 의미합니다.
	
	 사용 할 때에는 반드시 구현 객체를 담고 있는
	 인터페이스 변수를 통하여 호출할 수 있습니다.
	 */
	
	public default void log() { //public 은 생략 가능
		System.out.println("게시슬 서비스 로그입니다.");
	}
}
```

```
//NoticeService.class

public class NoticeService implements BoardService {	

	/*
	 디폴트 메소드는 구현 클래스에서 재정의 할 수 있습니다.
	 대부분의 구현 클래스의 공통 메소드는 인터페이스에서
	 디폴트 메소드로 정의 후 그 외 클래스에서 재정의해 사용할 수 있습니다.
	 */

	@Override
	public void log() {
		System.out.println("공지사항 게시판 실행중...");
	}
}
```

#### 정적 메소드 선언
자바8에서 추가된 인터페이스의 새로운 멤버  
문법) [public] static 리턴타입 메소드명(매개변수, ...) {...}

```
//Remote.interface

public interface Remote {

	/*
	 정적 메소드,
	 인터페이스의 기능으로 static 키워드를 사용하여 선언합니다.
	 사용 시 구현 객체 없이 인터페이스롤 사용할 수 있습니다.
	 */
	
	public static void changeBattery() { //public 은 생략 가능
		System.out.println("리모컨의 배터리를 교체합니다.");
	}
}
```

```
//Main.class

Remote.changeBattery(); //"리모컨의 배터리를 교체합니다." static이므로 인터페이스명 바로 호출
```

#### private 메소드 선언
문법) private static 리턴타입 메소드명(매개변수, ...) {...}

```
//BoardService.interface

public interface BoardService {

	public default void log() { //public은 생략 가능
		System.out.println("게시글 서비스 로그입니다.");
		method1();
		method2(); //static 메소드는 default 메소드에서 사용 가능합니다.
	}
	
	static void log2() {
		System.out.println("인터페이스의 기능입니다.");
		//method1(); private 메소드는 구현 클래스(객체) 소속이므로 static 메소드 사용x
		method2();
	}
	
	/*
	 private 메소드는 구현 클래스에서 재정의가 안됩니다.
	 주로 default 메소드 내에서 기능 모듈화를 위하여 사용합니다.
	 */
	
	private void method1() {
		System.out.println("private 메소드");
	}
	
	/*
	 private 메소드는 구현 클래스에서 재정의가 안됩니다.
	 주로 static 메소드 내에서 기능 모듈화를 위하여 사용합니다.
	 */
	
	private static void method2() {
		System.out.println("private 정적 메소드");		
	}
	
}
```

#### 다중 인터페이스 구현
한 클래스가 여러 인터페이스와 연결될 때  
문법) public class 구현클래스명 implements 인터페이스A, 인터페이스B {...}

```
//BoardService.interface

void list();
void write();
void modify();
void delete();
```

```
//LoginService.interface

void login();
void logout();
```

```
//MySystem.class

public class MySystem implements BoardService, LoginService {
	@Override
	public void list() {
		System.out.println("게시글 목록 조회");
	}

	@Override
	public void write() {
		System.out.println("게시글 등록");
	}

	@Override
	public void modify() {
		System.out.println("게시글 수정");
	}

	@Override
	public void delete() {
		System.out.println("게시글 삭제");
	}

	@Override
	public void login() {
		System.out.println("로그인 합니다.");
	}

	@Override
	public void logout() {
		System.out.println("로그아웃 합니다.");
	}
}
```

```
//Main.class

MySystem my = new MySystem();
		
/*
 다중 인터페이스를 구현하는 구현 객체는
 각각의 인터페이스에 모두 대입이 가능합니다.
 
 사용범위는 담겨있는 인터페이스의 추상 메소드 까지만 호출이 가능합니다.
 */
		
BoardService board = my;
board.list();
board.write();
board.modify();
board.delete();
//board.login(); //login() 메소드는 BoardService 인터페이스에는 존재x
		
LoginService loginService = my;
loginService.login();
loginService.logout();
//loginService.list(); //list() 메소드는 LoginService 인터페이스에는 존재x
```

#### 인터페이스 상속
- 인터페이스 역시 상속이 가능합니다.
- 인터페이스는 다중 상속이 가능합니다.(부모가 여러개 가능)
- 부모 인터페이스의 추상메소드들이 상속됩니다.
- 자식 인터페이스의 구현 클래스에서는 모든 부모 인터페이스의 추상메소드 까지 정의해야합니다.

```
//ParentInterface.interface

void parentMethod();
	
default void defaultParentMethod() {
	System.out.println("defaultParentMethod 메소드");
}
```

```
//Parent2Interface

void parent2Method();
```

```
//ChildInterface.interface

public interface ChildInterface extends ParentInterface, Parent2Interface {
	void childMehtod();
	
	//자식 인터페이스에서 부모의 default 메소드 재정의 할 수 있습니다.
	@Override
	default void defaultParentMethod() {
		System.out.println("defaultParentMethod Child 메소드");
	}
}
```

```
//ImpleClass.class

public class ImpleClass implements ChildInterface {

	public String impleField;
	
	public void impleMethod() {
		System.out.println("impleMethod()");
	}
	
	@Override
	public void parentMethod() {
		System.out.println("ParentInterface의 추상 메소드 정의");
	}

	@Override
	public void parent2Method() {
		System.out.println("Parent2Interface의 추상 메소드 정의");
	}

	@Override
	public void childMehtod() {
		System.out.println("ChildInterface의 추상 메소드 정의");
	}
	
	@Override
	public void defaultParentMethod() {
		System.out.println("defaultParentMethod 클래스 메소드");
	}
	
}
```

```
//Main.class

ChildInterface child = new ImpleClass();
child.childMehtod();
child.parentMethod(); //ChildInterface의 부모 ParentInterface의 추상메소드 사용 가능
child.parent2Method(); //ChildInterface의 부모 Parent2Interface의 추상메소드 사용 가능
		
ParentInterface parent = new ImpleClass(); //구현객체 ImpleClass는 ParentInterface의 추상메소드를 구현하고 있으므로 가능
//parent.childMethod(); ParentInterface에는 childMethod()가 없으므로 사용 x
//parent.parent2Method(); ParentInterface에는 parent2Method()가 없으므로 사용 x
parent.parentMethod();
```

#### 인터페이스에서의 자동형변환
- 구현객체를 인터페이스 타입변수에 대입하는 경우
- 구현객체의 자식 객체들 역시 해당 인터페이스의 자동형변환 대상입니다.

#### 인터페이스의 강제형변환
- 인터페이스에 담긴 구현객체를 다시 구현객체 타입으로 반환하는 경우 사용
- 인터페이스에 담긴 구현객체는 자신의 인스턴스 멤버(필드, 메소드)에는 접근 불가능 하므로 필요
- 문법) 구현클래스 변수명 = (구현클래스) 인터페이스변수;

```
//ParentInterface.interface

void parentMethod();
	
default void defaultParentMethod() {
	System.out.println("defaultParentMethod 메소드");
}
```

```
//Parent2Interface

void parent2Method();
```

```
//ChildInterface.interface

public interface ChildInterface extends ParentInterface, Parent2Interface {
	void childMehtod();
	
	//자식 인터페이스에서 부모의 default 메소드 재정의 할 수 있습니다.
	@Override
	default void defaultParentMethod() {
		System.out.println("defaultParentMethod Child 메소드");
	}
}
```

```
//ImpleClass.class

public class ImpleClass implements ChildInterface {

	public String impleField;
	
	public void impleMethod() {
		System.out.println("impleMethod()");
	}
	
	@Override
	public void parentMethod() {
		System.out.println("ParentInterface의 추상 메소드 정의");
	}

	@Override
	public void parent2Method() {
		System.out.println("Parent2Interface의 추상 메소드 정의");
	}

	@Override
	public void childMehtod() {
		System.out.println("ChildInterface의 추상 메소드 정의");
	}
	
	@Override
	public void defaultParentMethod() {
		System.out.println("defaultParentMethod 클래스 메소드");
	}
}
```

```
//ImpleChildClass.class

public class ImpleChildClass extends ImpleClass {
	
	public String childField;
	
	public void childImpleMethod() {
		System.out.println("childImpleMethod()");
	}
	
	@Override
	public void parentMethod() {
		System.out.println("ImpleChildClass에서 재정의");
	}
}
```

```
//Main.class

ImpleClass imple = new ImpleClass();
		
ImpleChildClass impleChild = new ImpleChildClass();
//상속
imple = impleChild; //자동형변환
		
//자식 객체 impleChild는 ImpleClass에서 ParentInterface를 구현하고
//있으므로 ParentInterface로 자동형변환이 가능하다.
p = impleChild;
p.parentMethod(); //마찬가지로 ParentInterface의 추상, 디폴트 메소드까지만 호출 가능
	
//p.childField = ""; ParentInterface에는 childField가 없으므로 오류
		
ImpleChildClass impleChildClass = (ImpleChildClass) p;
impleChildClass.childImpleMethod();
	
ImpleClass impleClass = (ImpleClass) p;
impleClass.childMehtod();
		
p = new ImpleClass();
if(p instanceof ImpleChildClass) {
	impleChildClass = (ImpleChildClass) p;
	impleChildClass.childImpleMethod();	
			
	impleChildClass.parentMethod(); //구현 클래스 타입으로는 인터페이스의 메소드, 구현 클래스 멤법(필드, 메소드) 호출 가능
}
if(p instanceof ImpleClass) {
	impleClass = (ImpleClass) p;
	impleClass.childMehtod();	
}
```

## 다형성
- 하나의 타입에 여러 가지 객체 대입해 다양한 실행 결과를 얻는 것
- 다형성을 구현하는 기술
	- 상속 또는 인터페이스의 자동 타입 변환(Promotion)
	- 오버라이딩(Overriding)
- 다형성의 효과
	- 다양한 실행 결과를 얻을 수 있음
	- 객체를 부품화시킬 수 있어 유지보수 용이 (메소드의 매개변수로 사용) 

#### 필드의 다형성

```
//MySystem.class

public class MySystem {
	public LoginService loginService;
}

```

```
//LoginService.interface

public interface LoginService {
	void login();
	void logout();
}
```

```
//NaverLogin.class

public class NaverLogin implements LoginService {

	@Override
	public void login() {
		System.out.println("네이버 계정에 로그인 합니다.");
	}

	@Override
	public void logout() {
		System.out.println("네이버 계정을 로그아웃 합니다.");
	}
}
```

```
//GoogleLogin.class

public class GoogleLogin implements LoginService {

	@Override
	public void login() {
		System.out.println("구글 계정에 로그인 합니다.");
	}

	@Override
	public void logout() {
		System.out.println("구글 계정을 로그아웃 합니다.");
	}

}
```

```
//Main.class

MySystem mySystem = new MySystem();
		
GoogleLogin google = new GoogleLogin();
NaverLogin naver = new NaverLogin();
		
mySystem.loginService = google; //google 정보 출력
//mySystem.loginService = naver; naver 정보 출력
		
mySystem.loginService.login();
mySystem.loginService.logout();
```

#### 매개변수의 다형성
매개 변수의 타입이 인터페이스인 경우
- 어떠한 구현 객체도 매개값으로 사용 가능
- 구현 객체에 따라 메소드 실행결과 달라짐

강제 타입 변환
- 인터페이스 타입으로 자동 타입 변환 후, 구현 클래스 타입으로 변환
	- 필요성: 구현 클래스 타입에 선언된 다른 멤버 사용하기 위해

객체 타입 확인(instanceof 연산자)
- 강제 타입 변환 전 구현 클래스 타입 조사

```
//MySystem.class

public class MySystem {
	public void list(BoardService boardService) {
		System.out.println("-----게시글 목록-----");
		for(String str : boardService.list()) {
			System.out.println(str);
		}
		System.out.println("------------------");
	}
	
	public void delete(BoardService boardService, int bno) {
		boardService.delete(bno);
	}
}
```

```
//BoardService.interface

public interface BoardService {
	String[] list();
	void delete(int bno);
}
```

```
//NoticeBoardService.class

public class NoticeBoardService implements BoardService {

	@Override
	public String[] list() {
		String[] result = {"공지사항1", "공지사항2", "공지사항3"};
		
		return result;
	}

	@Override
	public void delete(int bno) {
		System.out.println(bno+"번 공지사항이 삭제 되었습니다.");
	}
}
```

```
//FreeBoardService.class

public class FreeBoardService implements BoardService {

	@Override
	public String[] list() {
		String[] result = {"자유게시글1", "자유게시글2", "자유게시글3", "자유게시글4", "자유게시글5"};
		
		return result;
	}

	@Override
	public void delete(int bno) {
		System.out.println(bno+"번 자유게시글 삭제합니다.");
	}
}
```

```
//Main.class

MySystem mySystem = new MySystem();
			
NoticeBoardService notice = new NoticeBoardService();
FreeBoardService free = new FreeBoardService();
		
mySystem.list(free); //자유게시판 리스트 목록 출력
mySystem.delete(free, 10); //10번 자유게시판 삭제 출력
```

