---
title: 2026.01.20 java 기초(5)
date: 2026-01-20
categories: [국비교육]
tags: [java]
---

## 객체 지향 프로그래밍
부품 객체를 먼저 만들고 이것들을 하나씩 조립해 완성된 프로그램을 만드는 기법

#### 객체(Object)
객체란?
- 물리적으로 존재하는 것 (자동차, 책, 사람)
- 추상적인 것(회사, 날짜) 중에서 자신의 속성과 동작을 가지는 모든 것 
- 객체는 필드(속성) 과 메소드(동작)로 구성된 자바 객체로 모델링 가능

객체관의 관계
- 객체 지향 프로그램에서는 객체는 다른 객체와 관계를 맺음
- 관계의 종류
	- 집합 관계: 완성품과 부품의 관계
	- 사용 관계: 객체가 다른 객체를 사용하는 관계
	- 상속 관계: 종류 객체와  구체적인 사물 객체 관계

#### 객체 지향 프로그래밍의 특징
캡슐화
- 객체의 필드, 메소드를 하나로 묶고, 실제 구현 내용을 감추는 것
- 외부 객체는 객체 내부 구조를 알지 못하며 객체가 노출해 제공하는 필드와 메소드만 이용 가능
- 필드와 메소드를 캡슐화하여 보호하는 이유는 외부의 잘못된 사용으로 인해 객체가 손상되지 않도록 
- 자바 언어는 캡슐화된 멤버를 노출시킬 것인지 숨길 것인지 결정하기 위해 접근 제한자(Access Modifier) 사용

상속
- 상위(부모) 객체의 필드와 메소드를 하위(자식) 객체에게 물려주는 행위
- 하위 객체는 상위 객체를 확장해서 추가적인 필드와 메소드를 가질 수 있음
- 상속 대상: 필드와 메소드
- 상속의 효과
	- 상위 객체를 재사용해서 하위 객체를 빨리 개발 가능
	- 반복된 코드의 중복을 줄임
	- 유지 보수의 편리성 제공
	- 객체의 다형성 구현

다형성
- 같은 타입이지만 실행 결과가 다양한 객체를 대입할 수 있는 성질
- 다형성의 효과
	- 객체를 부품화시키는 것 가능
	- 유지보수 용이


## 객체와 클래스
현실세계 :  설계도 -> 객체 <br>
자바	     :  클래스 -> 객체

클래스에는 객체를 생성하기 위한 필드와 메소드가 정의 <br>
클래스로부터 만들어진 객체를 해당 클래스의 인스턴스(instance) <br>
하나의 클래스로부터 여러 개의 인스턴스를 만들 수 있음

#### 클래스 선언
클래스 이름
- 식별자 작성 규칙
	1. 하나 이상의 문자로 이루어져야 한다.
	2. 첫 번째 글자는 숫자가 올 수 없다.
	3. '$', '_' 외의 특수 문자는 사용할 수 없다.
	4. 자바 키워드는 사용할 수 없다.
- 알파벳 대소문자는 서로 다른 문자로 인식
- 첫 글자와 연결된 다른 단어의 첫 글자는 대문자로 작성하는 것이 관례

클래스 선언과 컴파일
- 소스 파일 생성: 클래스이름.java (대소문자 주의)
- 소스 파일당 하나의 클래스를 선언하는 것이 관례
- 두 개 이상의 클래스도 선언 가능
- 소스 파일 이름과 동일한 클래스만 public으로 선언 가능

클래스의 용도
- 1개의 애플리케이션 = (1개의 실행클래스) + (n개의 라이브러리 클래스)
- 라이브러리용
	- 자체적으로 실행되지 않음
	- 다른 클래스에서 이용할 목적으로 만든 클래스
- 실행용
	- main() 메소드를 가지고 있는 클래스로 실행할 목적으로 만든 클래스

클래스의 구성 멤버
- 필드 : 객체의 데이터가 저장되는 곳
- 생성자 : 객체 생성시 초기화 역할 담당
- 메소드 : 객체의 동작에 해당하느 실행 블록


#### 필드
객체의 고유 데이터 <br>
객체가 가져야 할 부품 객체 <br>
객체의 현재 상태 데이터

```
//Person.class

public class Person { //Person 이름의 클래스 선언, 라이브러리용
	
	//이름
	String name;
	//나이
	int age;
	
	//클래스 내부에서 필드 사용시에는 필드명으로만 사용할 수 있습니다.
	String info = name+", 나이는 "+age+"입니다.";

}
```

```
//Student.class

public class Student { 
	
	//학교명
	String schoolName = "한국스마트정보교육학교"; //생성되는 모든 Student 객체 초기값 대입

}
```

```
//Main.class

public class Main{

	public static void main(String[] args) { //실행용
		
		//클래스 변수 선언 : 클래스들은 모든 객체의 타입이 됩니다.
		Person person1;

		//클래스로 객체 생성
		person1 = new Person(); //new 클래스명() -> 클래스명 객체를 생성하고 생성된 객체의 주소값을 반환
		honggildong = new Student();

		//클래스에서 필드값을 초기화 하지 않으면 객체 생성시 0,0.0,false,null 등으로 초기화하여 생성
		System.out.println(person1.name); 

		//생성된 객체의 필드값 대입하기 (클래스변수.필드 = 값)
		person1.name = "홍길동"; 

		//필드 값 사용하기 (클래스변수.필드)
		System.out.println(person1.name);

		//Student.class 에서 초기값을 선언 했기 때문에 초기값 출력
		System.out.println(honggildong.schoolName);

		//변경 값을 대입하면 변경 값으로 출력
		honggildong.schoolName = "미국스마트정보교육학교";
		System.out.println(honggildong.schoolName);

	}
}
```

#### 생성자
new 연산자에 의해 호출되어 객체의 초기화 담당
- 필드의 값 설정
- 메소드 호출해 객체를 사용할 수 있도록 준비하는 역할 수행

기본 생성자
- 모든 클래스는 생성자가 반드시 존재하며 하나 이상 가질 수 있음

```
//Person.class

Person() { //기본생성자, 소스코드에서 생략 시 컴파일러가 class 파일에 작성하여 컴파일 해줍니다.
		
}
```


생성자 선언

```
//Person2.class

//컴파일러는 소스파일에 생성자가 하나라도 존재한다면 기본생성자를 만들지 않습니다.
//생성자의 매개변수 타입 순서와 매개값의 타입 순서가 같아야 호출할 수 있습니다.
Person2(String name, int arg2) { 
	System.out.println("Person2 생성자 호출!! "+name+", "+arg2);
		
	this.name = name; //현재 객체의 주소를 바라보는 this 키워드
	age = arg2; //age 변수명은 없고 필드만 존재하므로 this 키워드 생략
}

//이름
String name;
//나이
int age;
```

```
//Main2.class

Person2 person2 = new Person2("홍길동", 20); //Person2 생성자 호출!! 홍길동, 20

System.out.println(person2.name); //홍길동
System.out.println(person2.age); //20
```


생성자 다양화해야 하는 이유
- 객체 생성할 때 외부 값으로 객체를 초기화할 필요
- 외부 값이 어떤 타입으로 몇 개가 제공될 지 모름 - 생성자도 다양화

생성자 오버로딩(Overloading)
- 매개변수의 타입, 개수, 순서가 다른 생성자 여러 개 선언

```
//Person3.class

//1. 필드 이름, 성별을 초기화하는 생성자
Person3(String name, char gender){
	System.out.println("이름, 성별 초기화");
	this.name = name;
	this.gender = gender;
}

//2. 기본 생성자
Person3(){
	System.out.println("기본생성자");
}

//3. 필드 이름, 나이, 성별을 초기화하는 생성자
Person3(String name, int age, char gender){
	System.out.println("이름, 나이, 성별 초기화");
	this.name = name;
	this.age = age;
	this.gender = gender;
}

//4. 이름, 키를 초기화하는 생성자
Person3(String name, double height) {
	this.name = name;
	this.height = height;
}
	
//5. 주소, 몸무게를 초기화하는 생성자
//Person3(String address, double weight) 오류
Person3(double weight, String address) {
	this.address = address;
	this.weight = weight;
}
// *생성자 오버로딩 시 매개변수의 타입, 갯수, 순서는 같으면 안됩니다.


//관련 필드 선언...
```

```
//Main3.class

Person3 p1 = new Person3(); // "기본생성자" 출력
Person3 p2 = new Person3("홍길동", 'M'); // "이름, 성별 초기화"
Person3 p3 = new Person3("홍길동", 20, 'M'); // "이름, 나이, 성별 초기화"
```

#### 메소드
객체의 동작(기능)  
호출해서 실행할 수 있는 중괄호 { } 블록  
메소드 호출하면 중괄호 { } 블록에 있는 모든 코드들이 일괄 실행  
문법) 리턴타입 메소드이름 ([매개변수선언]) {...}

```
//Person.class

//인사 기능 : 메소드
void hello() {
	//클래스 내부에서 필드 사용하기 (호출 시점 필드 값을 불러옵니다.)
	System.out.println("-----"+name+"의 인사방법-----");
	System.out.println("한손을 든다.");
	System.out.println("들은 한손을 좌우로 흔든다.");
	System.out.println("안녕이라 말한다.");
}
```

```
//Student.class

void goSchool(String car) { // 매개변수 값을 설정
		System.out.println("신발을 신습니다.");
		System.out.println(car+"를 탑니다."); // goSchool 변수 안에서 매개변수 값 사용
		System.out.println("학교에 도착합니다.");
	}
```

```
//Main.class

Person honggildong; // 객체를 담을 클래스 변수 선언
honggildong = new Person(); // Person 타입 객체 생성하여 변수 대입
honggildong.name = "홍길동";
		
honggildong.hello(); // hello 메소드 호출 [클래스객체명.변수명();]

Student student001 = new Student();
student001.goSchool("택시"); // goSchool 변수에 값을 보냄
```


가변길이 매개변수  
매개값이 같은 타입으로 갯수가 가변적이라면 가변길이 매개변수를 사용하면 배열로 받아 처리할수 있습니다.

```
//Person.class

void eatingLaunch(String ... menus) { // 가변길이 매개변수 선언, (타입 ... 매개변수명) 사용
	System.out.println("점심을 먹어요.");
	for(String menu : menus) {
		System.out.print(menu+" ");
	}
	System.out.println("을 먹어요.");
	System.out.println("배불러요!");
}
```

```
//Main.class

kogildong.eatingLaunch("국밥"); // "국밥 을 먹어요." 출력
kogildong.eatingLaunch("국밥", "제육볶음", "커피"); // "국밥 제육볶음 커피 을 먹어요." 출력
```


리턴(return) 문
메소드 실행을 중지하고 리턴값 지정하는 역할  

리턴값이 있는 메소드
- 반드시 리턴(return)문 사용해 리턴값 지정해야 return 문 뒤에 실행문 올 수 없음

리턴값이 없는 메소드
- 메소드 실행을 강제 종료 시키는 역할

```
//Caculator.class

int plus(int num1, int num2) {
	int result;
	result = num1+num2;
	
	return result;
	//System.out.println("메소드 종료"); return 후에는 실행문 작성 X
}
```

```
//Main.class

Caculator cac = new Caculator();
			
int result = cac.plus(1, 2);
System.out.println("1+2="+result);
```
