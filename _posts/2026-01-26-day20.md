---
title: 2026.01.26 java 기초(8)
date: 2026-01-26
categories: [국비교육]
tags: [java]
---

## Getter와 Setter
클래스 선언할 때 필드는 일반적으로 private 접근 제한
- 읽기 전용 필드가 있을 수 있음 (Getter의 필요성)
- 외부에서 엉뚱한 값으로 변경할 수 없도록 (Setter의 필요성)
- 엔티티 클래스 : 객체의 값을 담고 있을 목적의 클래스
- 엔티티 클래스의 필드느 private 이고 값의 대입과 사용은 getter, setter

#### Getter
private 필드의 값을 리턴 하는 역할 - 필요할 경우 필드 값 가공  

getFieldName() 또는 isFieldName() 메소드
- 필드 타입이 boolean 일 경우 isFieldName()

```
//User.class

private String id;  //아이디

//getter : private인 필드의 값을 반환하는 목저의 메소드
public String getId() {  //id 값 반환 목적
	return id;  //필드 id 값 반환
}
```

```
//Main.class

User user1 = new User();

System.out.println(user1.getId());
```


#### Setter
외부에서 주어진 값을 필드 값으로 수정  
- 필요할 경우 외부의 값을 유효성 검사  

setFieldName(타입 변수) 메소드  
- 매개 변수 타입은 필드의 타입과 동일

```
//User.class

private String id;  //아이디

//객체 필드에 값을 대입하는 메소드 -> setter
public void setId(String id) {  //외부에서 전달되는 필드 id의 값을 검증하여 대입 목적
	//아이디는 5자리 이상인 경우 필드 대입
	if(id.length()>=5) {
		this.id = id;	
	}		
}
```

```
//Main.class

User user1 = new User();

user1.setId("hong");
```

## Singleton 싱글톤
싱글톤, 단 하나만 존재하는 객체를 의미

싱글톤 만들기
1. 생성자를 클래스 외부에서 호출하지 못하도록 만들어준다.
2. 단 한개의 자기 자신 객체를 참조할 정적 필드를 선언한 후 객체를 생성해 대입한다.
3. private 접근 제한자와 final 키워드를 사용하여 외부 호출할 수 없는 상수로 선언한다.
4. getInstance 메소드를 정의하여 정적필드 single을 반환한다.

```
//Single.class

public class Single {
	
	private static final Single single = new Single(); 
	
	private Single() {}
	
	public static Single getInstance() {
		return single;
	}
}
```

```
//Main.class

Single s1 = Single.getInstance();
Single s2 = Single.getInstance();
		
System.out.println(s1 == s2);  //true
```


## 상속
객체 지향 프로그램에서 상속이란
- 자식(하위, 파생) 클래스가 부모(상위) 클래스의 멤버를 물려받는 것
- 자식이 부모를 선택해 물려받음
- 상속 대상: 부모의 필드와 메소드

상속의 효과
- 부모 클래스 재사용해 자식 클래스 빨리 개발 가능
- 반복된 코드 중복 줄임
- 유지 보수 편리성 제공
- 객체 다형성 구현 가능

상속 대상 제한
- 부모 클래스의 private 접근 갖는 필드와 메소드 제외
- 부모 클래스가 다른 패키지에 있을 경우, default 접근 갖는 필드와 메소드도 제외

extends 키워드
- 자식 클래스가 상속할 부모 클래스를 지정하는 키워드

```
//Parent.class

public class Parent {
	...
}
```

```
//Child01.class

//Parent 클랫의 자식 클래스인 Child01 클래스 선언
//자식 클래스에서 extends 키워드를 사용하여 부모 클래스를 지정합니다.
//부모 클래스는 하나만 작성 가능합니다.

public class Child01 extends Parent {
	...
}
```

#### 부모 생성자 호출(super(...))
자식 객체 생성하면 부모 객체도 생성되는가?
- 부모 없는 자식 없음
	- 자식 객체 생성할 때는 부모 객체부터 생성 후 자식 객체 생성
	- 부모 생성자 호출 완료 후 자식 생성자 호출 완료

명시적인 부모 생성자 호출
- 부모 객체 생성할 때, 부모 생성자 선택해 호출
	- super(매개값,…) 
	- 부모 생성자 없다면 컴파일 오류 발생
	- 반드시 자식 생성자의 첫 줄에 위치
	- 부모 클래스에 기본(매개변수 없는) 생성자가 없다면 필수 작성

```
//Parent2.class

public class Parent2 {
	
	public Parent2(String arg) {
		System.out.println("매개변수 하나 있는 생성자, "+arg);
	}
	
}
```

```
//Child02.class

public class Child02 extends Parent2{
	
	public Child02() {
		//super 생성자는 부모객체를 생성하므로 무조건 자식 생성자 첫 실행문이여야 합니다.
		super("child02를 통한 생성자 호출"); 
		System.out.println("");
	}
	
}
```

## 메소드 재정의(Override)
메소드 재정의
- 상속에서의 오버라이딩이란, 부모의 메소드를 자식에서 재정의 하는 것을 의미합니다.	 
- @Override 어노테이션을 사용하면 컴파일시 부모 메소드의 선언부를 정확하게 체크 할 수 있습니다.
- 부모 메소드는 숨겨지는 효과 발생

규칙
- 부모 메소드의 선언부가 일치해야 합니다.
- 접근제한자는 더 약하게 변경 가능하나 더 강하게는 변경할 수 없습니다.

```
//Parent3.class

public class Parent3 {
	
	private void method1() {
		System.out.println("private 메소드");
	}
	
	void method2() {
		System.out.println("default 메소드");
	}
	
	public void method3() {
		System.out.println("public 메소드");
	}
}
```

```
//Child3.class

public class Child03 extends Parent3 {
	/*
	method1은 private이므로 갖고올수 없음
	private void method1() {
		
	}
	*/

	void method2() {
		System.out.println("자식 Child03에서 재정의한 default 메소드");
	}
	
	public void method3() {
		System.out.println("자식 Child03에서 재정의한 public 메소드");
	}
	
}

```

## final 키워드
final 필드 : 수정 불가 필드  
final 클래스 : 부모로 사용 불가한 클래스  
final 메소드 : 자식이 재정의할 수 없는 메소드

상속할 수 없는 final 클래스
- 자식 클래스 만들지 못하도록 final 클래스로 생성

```
public final class 클래스 {...}
public final class String {...}
public final NewString extends String {...}
```

오버라이딩 불가한 final 메소드
- 자식 클래스가 재정의 못하도록 부모 클래스의 메소드를 final로 생성

## protected 접근제한자
상속과 관련된 접근 제한자
- 같은 패키지 : default와 동일
- 다른 패키지 : 자식 클래스만 접근 허용

```
//java09 패키지 안에 Parent2.class 

package java09;

public class Parent2 {
	
	String field01; //default 접근제한자
	protected String field02; //protected 접근제한자
	
	public Parent2() {}
}
```

```
//sample 패키지 안에 Child02.class 
//다른 패키지에서 상속 시

package sample;

import java09.Parent2;

public class Child02 extends Parent2 {

	void method1() {
		System.out.println("부모 필드 사용하기");
		
		//field01 = "hong"; default 접근제한자 필드로 같은 패키지가 아니라 사용할 수 없다.
		field02 = "hong"; //protected 접근제한자 필드로 다른 패키지라도 자식 클래스이면 사용할 수 있다.
		System.out.println(field02);
	}
	
	public static void main(String[] args) {
		Child02 c =new Child02();
		c.method1();
	}
	
}
```


